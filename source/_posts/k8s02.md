---
title: 深入理解 Kubernetes 之 Kubectl
date: 2020-05-21 16:15:48
author: Rootkit
top: false
mathjax: false
categories: Kubernetes
tags:
  - Kubernetes
---



# 深入理解 Kubectl 

kubectl 是 Kubernetes 集群的命令行工具，通过 kubectl 能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署。运行 kubectl 命令的语法如下所示：

```bash
kubectl [command] [TYPE] [NAME] [flags]
```

**comand**：指定要对资源执行的操作，例如 create、get、describe 和 delete。

**TYPE**：指定资源类型，资源类型是大小学敏感的，开发者能够以单数、复数和缩略的形式。

**NAME**：指定资源的名称，名称也大小写敏感的。如果省略名称，则会显示所有的资源。

**flags**：指定可选的参数。

例如：

```bash
kubectl create -f nginx-deployment.yaml
```



## Kubectl 流程

![](/images/2020/kubectl.png)

Kubectl 的执行流程：

1. 用户发起请求

2. 根据用户执行动作分发给处理对应动作的 Cmd （Builder 设计模式）

3. 解析用户命令 （Visitor 设计模式）

4. 向Apiserver获取数据

5. 解析返回为通用的数据集合

   

## 源码分析

执行以下代码：

```bash
kubectl create -f nginx-deployment.yaml
```

### 入口

代码路径：

[`kubernetes/cmd/kubectl/kubectl.go`](https://github.com/kubernetes/kubernetes/blob/9e991415386e4cf155a24b1da15becaa390438d8/cmd/kubectl/kubectl.go#L35)

```go
func main() {
...
    // 准备command
	command := cmd.NewDefaultKubectlCommand()

    // 执行命令
	if err := command.Execute(); err != nil {
		os.Exit(1)
	}
}
```

### 命令匹配

代码路径：

[kubernetes/pkg/kubectl/cmd/cmd.go](https://github.com/kubernetes/kubernetes/blob/9e991415386e4cf155a24b1da15becaa390438d8/pkg/kubectl/cmd/cmd.go#L482)

```go
// 对用户输入的命令进行匹配
groups := templates.CommandGroups{
		{
			Message: "Basic Commands (Beginner):",
			Commands: []*cobra.Command{
				create.NewCmdCreate(f, ioStreams),
				expose.NewCmdExposeService(f, ioStreams),
				run.NewCmdRun(f, ioStreams),
				set.NewCmdSet(f, ioStreams),
			},
		}
		...
}
```



### 处理用户命令

代码路径：

[kubernetes/staging/src/k8s.io/kubectl/pkg/cmd/create/create.go](https://github.com/kubernetes/kubernetes/blob/9e991415386e4cf155a24b1da15becaa390438d8/staging/src/k8s.io/kubectl/pkg/cmd/create/create.go#L116)

匹配上 `create` 命令调用 `o.RunCreate(f,cmd)` 函数执行

```go
func NewCmdCreate(f cmdutil.Factory, ioStreams genericclioptions.IOStreams) *cobra.Command {
	o := NewCreateOptions(ioStreams)
	cmd := &cobra.Command{
		Use:                   "create -f FILENAME",
		DisableFlagsInUseLine: true,
		Short:                 i18n.T("Create a resource from a file or from stdin."),
		Long:                  createLong,
		Example:               createExample,
		Run: func(cmd *cobra.Command, args []string) {
			// 合法性检查
			cmdutil.CheckErr(o.Complete(f, cmd))
			cmdutil.CheckErr(o.ValidateArgs(cmd, args))
            // 执行命令
			cmdutil.CheckErr(o.RunCreate(f, cmd))
		},
	}
	// 创建子命令
	cmd.AddCommand(NewCmdCreateNamespace(f, ioStreams))
...
	return cmd
}
```



在 RunCreate 中时对该命令的具体处理，通过链式反应

`f.NewBuilder().Unstructured().Schema(schema).ContinueOnError().NamespaceParam(cmdNamespace).DefaultNamespace().FilenameParam().LabelSelectorParam().Flatten().Do()`

为执行命令做好数据准备。这段代码所做的事情是将命令行接收到的参数转化为一个资源的列。它也负责创建一个可以用来迭代访问所有资源的 Visitor 结构。这个命令比较复杂，因为它使用了Builder模式的变种，使用独立的函数做各自的数据初始化工作。

一旦所有的初始化都完成，resource.NewBuilder 函数会调用 Do 函数。`Do()` 函数是注册具体向 Apiserver 请求数据，和将返回数据转化为通用结构的函数。它会返回一个Result对象，并且将执行对资源的创建。Do 函数还会创建一个Visitor对象，可以用来遍历所有关联到 resource.NewBuilder 执行过程的资源。



```go
func (o *CreateOptions) RunCreate(f cmdutil.Factory, cmd *cobra.Command) error {
...
	r := f.NewBuilder().  // Builder 设计模式
		Unstructured().   // 支持非结构化数据
		Schema(schema).
		ContinueOnError().
		NamespaceParam(cmdNamespace).DefaultNamespace().
		FilenameParam(enforceNamespace, &o.FilenameOptions).
		LabelSelectorParam(o.Selector). // 设置用户的标签选择
		Flatten().  // 决定以何种方式从 Kubernetes 的返回数据中提取数据
		Do() // 执行命令获取数据
    
    // 创建 Visitor 对象，可以用来遍历所有关联到 Builder 执行过程的资源
	err = r.Visit(func(info *resource.Info, err error) error {
...
		return o.PrintObj(info.Object) // 打印对象
	})
...
}
```



### 发送请求并获取数据

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/builder.go ](https://github.com/kubernetes/kubernetes/blob/v1.18.0/staging/src/k8s.io/cli-runtime/pkg/resource/builder.go#L1098)

重要函数：

+ `RetrieveLazy` 中注册了从 Apiserver 获取数据的操作。
+ `NewDecoratedVisitor` 中注册了从获取到的数据结构中转化出通用数据的方法。

```go
func (b *Builder) Do() *Result {
	r := b.visitorResult()
	r.mapper = b.Mapper()
	if r.err != nil {
		return r
	}
	if b.flatten {
		r.visitor = NewFlattenListVisitor(r.visitor, b.objectTyper, b.mapper)
	}
    // 注册获取数据前的动作
	helpers := []VisitorFunc{}
	if b.defaultNamespace {
		helpers = append(helpers, SetNamespace(b.namespace))
	}
	if b.requireNamespace {
		helpers = append(helpers, RequireNamespace(b.namespace))
	}
	helpers = append(helpers, FilterNamespace)
     // 注册从 Apiserver 获取数据的方法
	if b.requireObject {
		helpers = append(helpers, RetrieveLazy)
	}
    // 注册从返回数据中提取信息的方法
	if b.continueOnError {
		r.visitor = NewDecoratedVisitor(ContinueOnErrorVisitor{r.visitor}, helpers...)
	} else {
		r.visitor = NewDecoratedVisitor(r.visitor, helpers...)
	}
	return r
}
```



```go
// RetrieveLazy updates the object if it has not been loaded yet.
func RetrieveLazy(info *Info, err error) error {
	if err != nil {
		return err
	}
	if info.Object == nil {
		return info.Get() // 从 API server 获取数据
	}
	return nil
}

```

而 NewDecoratedVisitor 函数注册了数据处理的关键函数 Visit， 这个函数可以使用户可以将来自 API server 的数据转化为通用数据集合。

```go
// Visit implements Visitor
func (v DecoratedVisitor) Visit(fn VisitorFunc) error {
	return v.visitor.Visit(func(info *Info, err error) error {
		if err != nil {
			return err
		}
		for i := range v.decorators {
			if err := v.decorators[i](info, nil); err != nil {
				return err
			}
		}
		return fn(info, nil)
	})
}
```



### 打印返回数据

```go
err = r.Visit(func(info *resource.Info, err error) error {
		
		if o.DryRunStrategy != cmdutil.DryRunClient {
			obj, err := resource.
				NewHelper(info.Client, info.Mapping).
				DryRun(o.DryRunStrategy == cmdutil.DryRunServer).
				Create(info.Namespace, true, info.Object)
			info.Refresh(obj, true)
		}
...
        // 打印数据 
		return o.PrintObj(info.Object)
	})
```



到此 Kubectl 的流程分析完毕。



## 重要数据结构及函数

### Client

在 Kubernetes 上，通常需要 Client 来访问 Kubernetes 中的对象，目前最常用的是RESTClient, DynamicClient和ClientSet 这三种Client。

#### RESTClient

RESTClient 是 Kubernetes最基础的 Client，直接负责与 Request(RESTClient中的概念)打交道。下面的 Demo 就描述如何生成一个RESTClient，并用该RESTClient获取某具体 Pod 的详细信息。

```go
package main
import (
	"flag"
	"fmt"
	"k8s.io/client-go/pkg/runtime"
	"k8s.io/client-go/pkg/runtime/serializer"
	"k8s.io/client-go/pkg/api"
	v1 "k8s.io/client-go/pkg/api/v1"
	"k8s.io/client-go/pkg/api/unversioned"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
)
func main() {
	kubeconfig := flag.String("kubeconfig", "/root/.kube/config", "Path to a kube config. Only required if out-of-cluster.")
	flag.Parse()
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		fmt.Println("BuildConfigFromFlags error")
	}
	groupversion := &unversioned.GroupVersion{"", "v1"}
	config.GroupVersion = groupversion
	config.APIPath = "/api"
	config.ContentType = runtime.ContentTypeJSON
	config.NegotiatedSerializer = serializer.DirectCodecFactory{CodecFactory: api.Codecs}
	restClient, err := rest.RESTClientFor(config)
	if err != nil {
		fmt.Println("RESTClientFor error")
	}
	pod := v1.Pod{}
	err = restClient.Get().Resource("pods").Namespace("default").Name("nginx-1487191267-b4w5j").Do().Into(&pod)
	if err != nil {
		fmt.Println("error")
	}
	fmt.Println(pod)
}
```

#### DynamicClient

RESTClient需要自己设置请求各属性，用起来很不方便。DynamicClient是对RESTClient的封装，支持动态设置访问类型。

```go
package main

import (
	"flag"
	"fmt"
	"reflect"
	"encoding/json"
	"k8s.io/client-go/pkg/api/v1"
	"k8s.io/client-go/pkg/api/unversioned"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/rest"
)

func main() {
	kubeconfig := flag.String("kubeconfig", "/root/.kube/config", "Path to a kube config. Only required if out-of-cluster.")
	fmt.Println(kubeconfig)
	flag.Parse()
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		fmt.Println("error1")
	}
	// 生成dynamicClient
	gv := &unversioned.GroupVersion{"", "v1"}
	resource := &unversioned.APIResource{Name: "pods", Namespaced: true}
	config.ContentConfig = rest.ContentConfig{GroupVersion: gv}
	config.APIPath = "/api"

	dynamicClient, err := dynamic.NewClient(config)
	if err != nil {
		fmt.Println("dynamic NewCLient error")
	}
	// 获取所有namespace的pod列表
	obj, err := dynamicClient.Resource(resource, "").List(&v1.ListOptions{})
	if err != nil {
		fmt.Println("dynamicClient Resource error")
	}
	js, err := json.Marshal(reflect.ValueOf(obj).Elem().Interface())
	if err != nil {
		fmt.Println("error")
	}
	podlist := v1.PodList{}
	json.Unmarshal(js, &podlist)
	fmt.Println(podlist)
	fmt.Println("------------------------")
	// 获取具体具体pod
	obj, err = dynamicClient.Resource(resource, "default").Get("nginx-1487191267-b4w5j")
        if err != nil {
                fmt.Println("dynamicClient Resource error")
        }
        js, err = json.Marshal(obj)
        if err != nil {
                fmt.Println("error")
        }
        pod := v1.Pod{}
        json.Unmarshal(js, &pod)
        fmt.Println(pod)
}
```

#### ClientSet

ClientSet也是对RESTClient的一种封装，与DynamicClient不同的是，ClientSet支持衍生出具体资源的Client，如PodClient等。ClientSet是Kubernetes用的最多的Client类型 。

```go
package main

import (
	"flag"
	"fmt"
	apiv1 "k8s.io/client-go/pkg/api/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

func main() {
	kubeconfig := flag.String("kubeconfig", "/root/.kube/config", "Path to a kube config. Only required if out-of-cluster.")
	fmt.Println(kubeconfig)
	flag.Parse()
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		fmt.Println("error")
	}
	// 生成clientset
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		fmt.Println("error")
	}
	// 生成podCLient
	podClient := clientset.Core().Pods("")
	pods, err := podClient.List(apiv1.ListOptions{})
	if err != nil {
		fmt.Println("error")
	}
	for _, pod := range pods.Items {
		fmt.Println(pod)
	}
}
```



### Builder

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/builder.go](https://github.com/kubernetes/kubernetes/blob/v1.18.0/staging/src/k8s.io/cli-runtime/pkg/resource/builder.go#L49)

Builder 的作用是将命令行输入的参数转换为资源列表，然后通过 visitor 接口迭代资源。

```go
type Builder struct {
	categoryExpanderFn CategoryExpanderFunc
	mapper *mapper
	clientConfigFn ClientConfigFunc
	restMapperFn RESTMapperFunc
	objectTyper runtime.ObjectTyper
	negotiatedSerializer runtime.NegotiatedSerializer
	local bool
	errs []error
	paths  []Visitor
	stream bool
	dir    bool
	labelSelector     *string
	fieldSelector     *string
	selectAll         bool
	limitChunks       int64
	requestTransforms []RequestTransform
	resources []string
	namespace    string
	allNamespace bool
	names        []string
	resourceTuples []resourceTuple
	defaultNamespace bool
	requireNamespace bool
	flatten bool
	latest  bool
	requireObject bool
	singleResourceType bool
	continueOnError    bool
	singleItemImplied bool
	export bool
	schema ContentValidator
}

## Method

## path
func (b *Builder) Path(paths ...string) *Builder {}

## selector
func (b *Builder) SelectorParam(s string) *Builder {}
func (b *Builder) Selector(selector labels.Selector) *Builder {}
func (b *Builder) SelectAllParam(selectAll bool) *Builder{}

## namespace
func (b *Builder) NamespaceParam(namespace string) *Builder {}
func (b *Builder) DefaultNamespace() *Builder {}
func (b *Builder) AllNamespaces(allNamespace bool) *Builder {}

## resource
func (b *Builder) ResourceNames(resource string, names ...string) *Builder {}
func (b *Builder) ResourceTypes(types ...string) *Builder {}
func (b *Builder) ResourceTypeOrNameArgs() *Builder{}

## url
func (b *Builder) URL(urls ...*url.URL) *Builder {}

## stream
func (b *Builder) Stream(r io.Reader, name string) *Builder {}

## stdin
func (b *Builder) Stdin() *Builder {}
```

Builder是 Kubectl 命令行信息的内部载体，可以通过 Builder 生成Result对象。Builder大多方法支持链式调用：

```go
resource.NewBuilder(mapper, typer, resource.ClientMapperFunc(f.UnstructuredClientForMapping), runtime.UnstructuredJSONScheme).
		NamespaceParam(cmdNamespace).DefaultNamespace().AllNamespaces(allNamespaces).
		FilenameParam(enforceNamespace, &options.FilenameOptions).
		SelectorParam(selector).
		ExportParam(export).
		ResourceTypeOrNameArgs(true, args...).
		ContinueOnError().
		Latest().
		Flatten().
		Do()
```

#### NewBuilder()

NewBuilder() 生成一个Builder，新的 Builder只设置了 mapper，及标记 requireObject 为true。

```
func NewBuilder(mapper meta.RESTMapper, typer runtime.ObjectTyper, clientMapper ClientMapper, decoder runtime.Decoder) *Builder {
	return &Builder{
		// 把RESTMapper, ObjectTyper, ClientMapper, Decoder封装成kubectl的Mapper
		mapper:        &Mapper{typer, mapper, clientMapper, decoder},
		requireObject: true,
	}
}
```

#### Do()

Do() 先调用 visitorResult() 生成 Result 对象，然后设置 Result 对象中的 Visitor。

```
// 返回一个 *Result，Result可以使Infos()或Object()来获取执行结果
// 关于 visitor 层层封装，可以理解为每个 visitor 实现一定的功能，然后按一定的顺序来执行这些功能
func (b *Builder) Do() *Result {
	r := b.visitorResult()
	if r.err != nil {
		return r
	}
	// 层层封装visitor
	if b.flatten {
		r.visitor = NewFlattenListVisitor(r.visitor, b.mapper)
	}
	helpers := []VisitorFunc{}
	if b.defaultNamespace {
		helpers = append(helpers, SetNamespace(b.namespace))
	}
	if b.requireNamespace {
		helpers = append(helpers, RequireNamespace(b.namespace))
	}
	helpers = append(helpers, FilterNamespace)
	if b.requireObject {
		helpers = append(helpers, RetrieveLazy)
	}
	r.visitor = NewDecoratedVisitor(r.visitor, helpers...)
	if b.continueOnError {
		r.visitor = ContinueOnErrorVisitor{r.visitor}
	}
	return r
}
```

#### visitResult()

visitResult() 会根据 Builder 中字段的设置情况来生成不同的 Result。一般来说 b.paths, b.selectors, b.resourceTuples, b.names 只需设置一个即可。

```go
// 返回一个result对象
// visitByPaths()等会生成info对象
func (b *Builder) visitorResult() *Result {
	if len(b.errs) > 0 {
		return &Result{err: utilerrors.NewAggregate(b.errs)}
	}
	//***设置selector为labels.Everything()***//
	if b.selectAll {
		b.selector = labels.Everything()
	}
	// visit items specified by paths
	if len(b.paths) != 0 {
		return b.visitByPaths()
	}
	// visit selectors
	if b.selector != nil {
		return b.visitBySelector()
	}
	// visit items specified by resource and name
	if len(b.resourceTuples) != 0 {
		return b.visitByResource()
	}
	// visit items specified by name
	if len(b.names) != 0 {
		return b.visitByName()
	}
	if len(b.resources) != 0 {
		return &Result{err: fmt.Errorf("resource(s) were provided, but no name, label selector, or --all flag specified")}
	}
	return &Result{err: missingResourceError}
}
```



#### visitBySelector()

visitBySelector()生成一个Selector visitor，然后把该visitor封装成Result并返回。

```go
// selector visitor 的 visitFunc 会生成 Info
func (b *Builder) visitBySelector() *Result {
	if len(b.names) != 0 {
		return &Result{err: fmt.Errorf("name cannot be provided when a selector is specified")}
	}
	if len(b.resourceTuples) != 0 {
		return &Result{err: fmt.Errorf("selectors and the all flag cannot be used when passing resource/name arguments")}
	}
	if len(b.resources) == 0 {
		return &Result{err: fmt.Errorf("at least one resource must be specified to use a selector")}
	}
	mappings, err := b.resourceMappings()
	if err != nil {
		return &Result{err: err}
	}
	visitors := []Visitor{}
	for _, mapping := range mappings {
		// 生成 client
		client, err := b.mapper.ClientForMapping(mapping)
		if err != nil {
			return &Result{err: err}
		}
		selectorNamespace := b.namespace
		if mapping.Scope.Name() != meta.RESTScopeNameNamespace {
			selectorNamespace = ""
		}
		visitors = append(visitors, NewSelector(client, mapping, selectorNamespace, b.selector, b.export))
	}
	if b.continueOnError {
		return &Result{visitor: EagerVisitorList(visitors), sources: visitors}
	}
	return &Result{visitor: VisitorList(visitors), sources: visitors}
}
```

#### visitByResource()

visitByResource()使用 resourceTuples 生成 Info ，Info 本身也是个 visitor，所以把 Info 打包成Result 并返回。

```go
//通过 resource 生成 info
func (b *Builder) visitByResource() *Result {
	isSingular := b.singular
	if !isSingular {
		isSingular = len(b.resourceTuples) == 1
	}
	if len(b.resources) != 0 {
		return &Result{singular: isSingular, err: fmt.Errorf("you may not specify individual resources and bulk resources in the same call")}
	}
	// retrieve one client for each resource
	mappings, err := b.resourceTupleMappings()
	if err != nil {
		return &Result{singular: isSingular, err: err}
	}
	clients := make(map[string]RESTClient)
	for _, mapping := range mappings {
		s := fmt.Sprintf("%s/%s", mapping.GroupVersionKind.GroupVersion().String(), mapping.Resource)
		if _, ok := clients[s]; ok {
			continue
		}
		client, err := b.mapper.ClientForMapping(mapping)
		if err != nil {
			return &Result{err: err}
		}
		clients[s] = client
	}
	items := []Visitor{}
	for _, tuple := range b.resourceTuples {
		mapping, ok := mappings[tuple.Resource]
		if !ok {
			return &Result{singular: isSingular, err: fmt.Errorf("resource %q is not recognized: %v", tuple.Resource, mappings)}
		}
		s := fmt.Sprintf("%s/%s", mapping.GroupVersionKind.GroupVersion().String(), mapping.Resource)
		client, ok := clients[s]
		if !ok {
			return &Result{singular: isSingular, err: fmt.Errorf("could not find a client for resource %q", tuple.Resource)}
		}
		selectorNamespace := b.namespace
		if mapping.Scope.Name() != meta.RESTScopeNameNamespace {
			selectorNamespace = ""
		} else {
			if len(b.namespace) == 0 {
				errMsg := "namespace may not be empty when retrieving a resource by name"
				if b.allNamespace {
					errMsg = "a resource cannot be retrieved by name across all namespaces"
				}
				return &Result{singular: isSingular, err: fmt.Errorf(errMsg)}
			}
		}
		//生成 Info
		info := NewInfo(client, mapping, selectorNamespace, tuple.Name, b.export)
		items = append(items, info)
	}
	var visitors Visitor
	if b.continueOnError {
		visitors = EagerVisitorList(items)
	} else {
		visitors = VisitorList(items)
	}
	return &Result{singular: isSingular, visitor: visitors, sources: items}
}
```

#### visitByName()

visitByName()先通过b.names来生成info，然后封装成Result返回。

```go
//通过 resource name 生成 Info
func (b *Builder) visitByName() *Result {
	isSingular := len(b.names) == 1
	if len(b.paths) != 0 {
		return &Result{singular: isSingular, err: fmt.Errorf("when paths, URLs, or stdin is provided as input, you may not specify a resource by arguments as well")}
	}
	if len(b.resources) == 0 {
		return &Result{singular: isSingular, err: fmt.Errorf("you must provide a resource and a resource name together")}
	}
	if len(b.resources) > 1 {
		return &Result{singular: isSingular, err: fmt.Errorf("you must specify only one resource")}
	}
	mappings, err := b.resourceMappings()
	if err != nil {
		return &Result{singular: isSingular, err: err}
	}
	mapping := mappings[0]
	client, err := b.mapper.ClientForMapping(mapping)
	if err != nil {
		return &Result{err: err}
	}
	selectorNamespace := b.namespace
	if mapping.Scope.Name() != meta.RESTScopeNameNamespace {
		selectorNamespace = ""
	} else {
		if len(b.namespace) == 0 {
			errMsg := "namespace may not be empty when retrieving a resource by name"
			if b.allNamespace {
				errMsg = "a resource cannot be retrieved by name across all namespaces"
			}
			return &Result{singular: isSingular, err: fmt.Errorf(errMsg)}
		}
	}
	visitors := []Visitor{}
	for _, name := range b.names {
		// 生成 Info
		info := NewInfo(client, mapping, selectorNamespace, name, b.export)
		visitors = append(visitors, info)
	}
	return &Result{singular: isSingular, visitor: VisitorList(visitors), sources: visitors}
}
```

#### visitByPaths()

visitByPaths() 根据 b.Paths 生成 Results。因为 b.Paths 本身就是个 Visitor 数组。

```go
//Paths 中的 Visitor 会生成 Info
func (b *Builder) visitByPaths() *Result {
	singular := !b.dir && !b.stream && len(b.paths) == 1
	if len(b.resources) != 0 {
		return &Result{singular: singular, err: fmt.Errorf("when paths, URLs, or stdin is provided as input, you may not specify resource arguments as well")}
	}
	if len(b.names) != 0 {
		return &Result{err: fmt.Errorf("name cannot be provided when a path is specified")}
	}
	if len(b.resourceTuples) != 0 {
		return &Result{err: fmt.Errorf("resource/name arguments cannot be provided when a path is specified")}
	}
	var visitors Visitor
	if b.continueOnError {
		//此处 path 也是 Visitor
		//FileVisitor, StreamVisitor 会生成 Info
		visitors = EagerVisitorList(b.paths)
	} else {
		visitors = VisitorList(b.paths)
	}
	// only items from disk can be refetched
	if b.latest {
		// must flatten lists prior to fetching
		if b.flatten {
			visitors = NewFlattenListVisitor(visitors, b.mapper)
		}
		// must set namespace prior to fetching
		if b.defaultNamespace {
			visitors = NewDecoratedVisitor(visitors, SetNamespace(b.namespace))
		}
		visitors = NewDecoratedVisitor(visitors, RetrieveLatest)
	}
	if b.selector != nil {
		visitors = NewFilteredVisitor(visitors, FilterBySelector(b.selector))
	}
	return &Result{singular: singular, visitor: visitors, sources: b.paths}
}
```



**接下来是Builder 的字段设置函数**

#### Schema()

Schema() 设置Builder的 schema 字段。schema 可以对资源名称进行规范检查。

```go
func (b *Builder) Schema(schema validation.Schema) *Builder {
	b.schema = schema
	return b
}
```

#### FilenameParam()

FilenameParam()可以处理不同的输入方式，并设置 Paths 字段。如`kubectl create -f abc.yaml`，则filenameOptions为&{[/home/abc.yaml] false}。
FilenameParam()目前支持标准输入，URL方式，文件方式，对应的支持函数为Stdin(), URL(), Path()。

```go
func (b *Builder) FilenameParam(enforceNamespace bool, filenameOptions *FilenameOptions) *Builder {
	recursive := filenameOptions.Recursive
	paths := filenameOptions.Filenames
	for _, s := range paths {
		switch {
		// 标准输入
		case s == "-":
			b.Stdin()
		// URL
		case strings.Index(s, "http://") == 0 || strings.Index(s, "https://") == 0:
			url, err := url.Parse(s)
			if err != nil {
				b.errs = append(b.errs, fmt.Errorf("the URL passed to filename %q is not valid: %v", s, err))
				continue
			}
			b.URL(defaultHttpGetAttempts, url)
		default:
			if !recursive {
				b.singular = true
			}
			// 文件或目录输入
			b.Path(recursive, s)
		}
	}

	// 如果enforceNamespace为true，则调用RequireNamespace()
	if enforceNamespace {
		b.RequireNamespace()
	}

	return b
}
```



#### Stdin()

`Stdin()`会调用 `FileVIsitorForSTDIN()` 生成一个 Visitor，然后把该 Visitor 加入到 paths 中。

```go
// 在 Builder 的 paths 中加入 stdin Visitor
func (b *Builder) Stdin() *Builder {
	b.stream = true
	b.paths = append(b.paths, FileVisitorForSTDIN(b.mapper, b.schema))
	return b
}
```



#### URL()

URL() 先生成一个 url Visitor，然后把该 visitor 加入到 paths 中。

```go
// 在 Builder 的 paths 中加入 URL Visitor
func (b *Builder) URL(httpAttemptCount int, urls ...*url.URL) *Builder {
	for _, u := range urls {
		b.paths = append(b.paths, &URLVisitor{
			URL:              u,
			StreamVisitor:    NewStreamVisitor(nil, b.mapper, u.String(), b.schema),
			HttpAttemptCount: httpAttemptCount,
		})
	}
	return b
}
```



#### Stream()

Stream() 先生成一个 stream Visitor，然后把该 Visitor 加入到 paths 中。

```go
// 在 Builder 的 paths 中加入 stream Visitor 
func (b *Builder) Stream(r io.Reader, name string) *Builder {
	b.stream = true
	b.paths = append(b.paths, NewStreamVisitor(r, b.mapper, name, b.schema))
	return b
}
```



#### Path()

Path()把路径转换成 file visitor,然后加入到 paths 中。

```go
// 把path转换成file Visitor，然后加入到paths中
func (b *Builder) Path(recursive bool, paths ...string) *Builder {
	for _, p := range paths {
		_, err := os.Stat(p)
		if os.IsNotExist(err) {
			b.errs = append(b.errs, fmt.Errorf("the path %q does not exist", p))
			continue
		}
		if err != nil {
			b.errs = append(b.errs, fmt.Errorf("the path %q cannot be accessed: %v", p, err))
			continue
		}

		// 把paths转换成file Visitors
		visitors, err := ExpandPathsToFileVisitors(b.mapper, p, recursive, FileExtensions, b.schema)
		if err != nil {
			b.errs = append(b.errs, fmt.Errorf("error reading %q: %v", p, err))
		}
		if len(visitors) > 1 {
			b.dir = true
		}

		// 加入到paths中
		b.paths = append(b.paths, visitors...)
	}
	return b
}
```



#### ResourceTypes()

ResourceTypes()设置Builder的resources字段，如kubectl get pods abc，则resources为pods

```go
// 设置resources/
// builder resources中存储的是需要处理的类型
func (b *Builder) ResourceTypes(types ...string) *Builder {
	b.resources = append(b.resources, types...)
	return b
}
```



#### ResourceNames()

ResourceNames()设置resourceTuples字段，表示需要访问的对象。如果kubectl logs nginx，那么ResourceNames()会把”nginx”和Builder中的resource(logs命令中设置为pods)，组成(pods, nginx)加入到resourceTuples中。

```go
func (b *Builder) ResourceNames(resource string, names ...string) *Builder {
	for _, name := range names {
		// See if this input string is of type/name format
		tuple, ok, err := splitResourceTypeName(name)
		if err != nil {
			b.errs = append(b.errs, err)
			return b
		}

		if ok {
			b.resourceTuples = append(b.resourceTuples, tuple)
			continue
		}
		if len(resource) == 0 {
			b.errs = append(b.errs, fmt.Errorf("the argument %q must be RESOURCE/NAME", name))
			continue
		}

		// Use the given default type to create a resource tuple
		b.resourceTuples = append(b.resourceTuples, resourceTuple{Resource: resource, Name: name})
	}
	return b
}
```



#### SelectorParam()

SelectorParam()的参数为string,设置Builder的selector字段。

```go
// 设置selector
func (b *Builder) SelectorParam(s string) *Builder {
	selector, err := labels.Parse(s)
	if err != nil {
		b.errs = append(b.errs, fmt.Errorf("the provided selector %q is not valid: %v", s, err))
		return b
	}
	if selector.Empty() {
		return b
	}
	if b.selectAll {
		b.errs = append(b.errs, fmt.Errorf("found non empty selector %q with previously set 'all' parameter. ", s))
		return b
	}
	return b.Selector(selector)
}
```



#### Selector()

Selector()的参数为selector，直接设置Builder的selector字段。

```go
func (b *Builder) Selector(selector labels.Selector) *Builder {
	b.selector = selector
	return b
}
```



#### ExportParam()

资源是否可导出

```go
func (b *Builder) ExportParam(export bool) *Builder {
	b.export = export
	return b
}
```



#### NamespaceParam()

NamespaceParam()可以设置Builder的namespace字段。

```go
func (b *Builder) NamespaceParam(namespace string) *Builder {
	b.namespace = namespace
	return b
}
```



#### DefaultNamespace()

DefaultNamespace()可以设置Builder的defaultNamespace字段，表示如果namespace未指定，是否使用default namespace。

```go
// 设置DefaultNamespace
func (b *Builder) DefaultNamespace() *Builder {
	b.defaultNamespace = true
	return b
}
```

#### AllNamespaces()

AllNamespaces()可以设置Builder的allNamespace和namespace字段，表示访问NamespaceAll。

```go
// 把namespace设置为NamespaceAll
func (b *Builder) AllNamespaces(allNamespace bool) *Builder {
	if allNamespace {
		b.namespace = api.NamespaceAll
	}
	b.allNamespace = allNamespace
	return b
}
```



#### RequireNamespace()

RequireNamespace()可以设置Builder的requireNamespace字段。

```
func (b *Builder) RequireNamespace() *Builder {
	b.requireNamespace = true
	return b
}
```



#### SelectAllParam()

SelectAllParam()可以设置Builder的selectAll字段。与selector字段互斥。

```
func (b *Builder) SelectAllParam(selectAll bool) *Builder {
	if selectAll && b.selector != nil {
		b.errs = append(b.errs, fmt.Errorf("setting 'all' parameter but found a non empty selector. "))
		return b
	}
	b.selectAll = selectAll
	return b
}
```



#### ResourceTypeOrNameArgs()

ResourceTypeOrNameArgs()可以设置Builder的names和resource字段。如执行`kubectl get pods/nginx-1487191267-b4w5j rc/abc`，则args为`[pods/nginx-1487191267-b4w5j rc/abc]`。

```go
func (b *Builder) ResourceTypeOrNameArgs(allowEmptySelector bool, args ...string) *Builder {
	args = normalizeMultipleResourcesArgs(args)
	if ok, err := hasCombinedTypeArgs(args); ok {
		if err != nil {
			b.errs = append(b.errs, err)
			return b
		}
		for _, s := range args {
			tuple, ok, err := splitResourceTypeName(s)
			if err != nil {
				b.errs = append(b.errs, err)
				return b
			}
			if ok {
				b.resourceTuples = append(b.resourceTuples, tuple)
			}
		}
		return b
	}
	if len(args) > 0 {
		// Try replacing aliases only in types
		args[0] = b.ReplaceAliases(args[0])
	}
	// 此处调用ResourceTypes()
	switch {
	case len(args) > 2:
		b.names = append(b.names, args[1:]...)
		b.ResourceTypes(SplitResourceArgument(args[0])...)
	case len(args) == 2:
		b.names = append(b.names, args[1])
		b.ResourceTypes(SplitResourceArgument(args[0])...)
	case len(args) == 1:
		b.ResourceTypes(SplitResourceArgument(args[0])...)
		if b.selector == nil && allowEmptySelector {
			b.selector = labels.Everything()
		}
	case len(args) == 0:
	default:
		b.errs = append(b.errs, fmt.Errorf("arguments must consist of a resource or a resource and name"))
	}
	return b
}
```



#### Flatten()

Flatten()可以设置Builder的flatten字段。

```go
func (b *Builder) Flatten() *Builder {
	b.flatten = true
	return b
}
```



#### Latest()

Latest()可以设置Builder的latest字段，用来标识获取URL或Path中最新的内容。

```go
func (b *Builder) Latest() *Builder {
	b.latest = true
	return b
}
```



#### RequireObject()

RequireObject()可以设置Builder的requireObject字段。

```go
func (b *Builder) RequireObject(require bool) *Builder {
	b.requireObject = require
	return b
}
```



#### ContinueOnError()

ContinueOnError()可以设置Builder的continueOnError字段为true，在封装visitor时会用到该字段。

```go
func (b *Builder) ContinueOnError() *Builder {
	b.continueOnError = true
	return b
}
```



#### mappingFor()

mappingFor()使用参数resource，然后依据mapper字段，构建RESTMapping并返回。RESTMapping表示resource和GVK的对应关系。

```go
// 返回 RESTMapping
func (b *Builder) mappingFor(resourceArg string) (*meta.RESTMapping, error) {
	// 把resource构造成GVR
	fullySpecifiedGVR, groupResource := unversioned.ParseResourceArg(resourceArg)
	gvk := unversioned.GroupVersionKind{}
	if fullySpecifiedGVR != nil {
		gvk, _ = b.mapper.KindFor(*fullySpecifiedGVR)
	}
	if gvk.Empty() {
		var err error
		gvk, err = b.mapper.KindFor(groupResource.WithVersion(""))
		if err != nil {
			return nil, err
		}
	}

	// RESTMapping()定义在/pkg/api/meta/restmapper.go中
	return b.mapper.RESTMapping(gvk.GroupKind(), gvk.Version)
}
```



#### resourceMappings()

resourceMappings()把Builder中的resource传递给上面的mappingFor()生成RESTMapping。

```go
// 把builder中resources转换成mapping
func (b *Builder) resourceMappings() ([]*meta.RESTMapping, error) {
	if len(b.resources) > 1 && b.singleResourceType {
		return nil, fmt.Errorf("you may only specify a single resource type")
	}
	mappings := []*meta.RESTMapping{}
	for _, r := range b.resources {
		mapping, err := b.mappingFor(r)
		if err != nil {
			return nil, err
		}

		mappings = append(mappings, mapping)
	}
	return mappings, nil
}
```



#### resourceTupleMappings()

resourceTupleMappings()把Builder中的resourceTuple转换成RESTMapping。

```go
func (b *Builder) resourceTupleMappings() (map[string]*meta.RESTMapping, error) {
	mappings := make(map[string]*meta.RESTMapping)
	canonical := make(map[string]struct{})
	for _, r := range b.resourceTuples {
		if _, ok := mappings[r.Resource]; ok {
			continue
		}
		mapping, err := b.mappingFor(r.Resource)
		if err != nil {
			return nil, err
		}

		mappings[mapping.Resource] = mapping
		mappings[r.Resource] = mapping
		canonical[mapping.Resource] = struct{}{}
	}
	if len(canonical) > 1 && b.singleResourceType {
		return nil, fmt.Errorf("you may only specify a single resource type")
	}
	return mappings, nil
}
```



### Visitor

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/interfaces.go](https://github.com/kubernetes/kubernetes/blob/v1.18.0/staging/src/k8s.io/cli-runtime/pkg/resource/interfaces.go#L94)

Builder 最后调用 `DO()` 函数的作用就是构建 Visitors ,根据不同的资源构建不同的 Visitor，然后通过 `Visit` 函数访问不同的资源。

```go
// 通过访问者模式，访问资源列表
type Visitor interface {
	Visit(VisitorFunc) error
}

// 访问者回调函数
type VisitorFunc func(*Info, error) error
```

可以看出，只要实现了 `Visit(VisitorFunc) error` 方法的结构体都可以称为 Visitor。

其中 VisitorFunc 的参数为 *Info 及 error，所以可以推断，VisitorFunc() 可以对 Info 及 Error 进行处理。

Visitor 最大的特性就是每个 Visitor 实现了一个特性，然后可以嵌套使用。Visitor 可以分为两类，第一类是生成Info，第二类是处理 Info。我们现在先记着 Info 是用来存储REST请求的返回结果的。

产生 Info 的 Visitor 有：FileVisitor, StreamVisitor, URLVisitor, Selector。

处理 Info 的 Visitor 有：VisitorList, EagerVisitorList, DecoratedVisitor, ContinueOnErrorVisitor, FlattenListVisitor, FlattenListVisitor 等。此处需要说明下，有些 Visitor 只处理了 Error，但我们仍把它归为处理 Info 的 Visitor。

一般来说，如果 Info 已经生成，那么 Visitor 嵌套中的 Visitor 只要 Info 处理 Visitor 即可；如果没有 Info ，则最里面的 Visitor 要在`fn()`调用之前生成 Info ，以供其他 Visitor 处理。

我们接下来详细看下对应的Visitor 。

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/visitor.go](https://github.com/kubernetes/kubernetes/blob/v1.18.0/staging/src/k8s.io/cli-runtime/pkg/resource/visitor.go)

#### VisitorList

VisitorList 也属于 Visitor 类型。

```
type VisitorList []Visitor

// 遍历 Visitor，执行 Visit 函数
func (l VisitorList) Visit(fn VisitorFunc) error {
	for i := range l {
		if err := l[i].Visit(fn); err != nil {
			return err
		}
	}
	return nil
}
```

#### EagerVisitorList

EagerVisitorList 在迭代包含的 Visitor 时，遇到错误会断续迭代，最后一起返回所有错误。

所有匿名函数中的 err 都会被收集到 EagerVisitorList 的 Visit() 方法中的 errs 中。

```go
type EagerVisitorList []Visitor

func (l EagerVisitorList) Visit(fn VisitorFunc) error {
	errs := []error(nil)
	for i := range l {
		if err := l[i].Visit(func(info *Info, err error) error {
			if err != nil {
				errs = append(errs, err)
				return nil
			}
			if err := fn(info, nil); err != nil {
				errs = append(errs, err)
			}
			return nil
		}); err != nil {
			errs = append(errs, err)
		}
	}
	return utilerrors.NewAggregate(errs)
}
```



#### Info

其他 Visitor 最终会转换为 Info ，Info 负责向 API server 发起 http 请求，或者返回 http 请求响应的结果。

```GO
type Info struct {
	Client RESTClient
	Mapping *meta.RESTMapping
	Namespace string
	Name      string
	Source string
	Object runtime.Object
	ResourceVersion string
	Export bool
}
func (i *Info) Visit(fn VisitorFunc) error {
	return fn(i, nil)
}

// Get()调用 Helper 依据Info中的信息获取 obj，并更新到 Info 的Object字段。
func (i *Info) Get() (err error) {
	obj, err := NewHelper(i.Client, i.Mapping).Get(i.Namespace, i.Name, i.Export)
	if err != nil {
        ...
			err2 := i.Client.Get().AbsPath("api", "v1", "namespaces", i.Namespace).Do(context.TODO()).Error()
        ...
		return err
	}
    // 更新i.Object和i.ResourceVersion
	i.Object = obj
	i.ResourceVersion, _ = metadataAccessor.ResourceVersion(obj)
	return nil
}

// 把一个 object 更新到 Info 中
func (i *Info) Refresh(obj runtime.Object, ignoreError bool) error {
	name, err := i.Mapping.MetadataAccessor.Name(obj)
	if err != nil {
		if !ignoreError {
			return err
		}
	} else {
		i.Name = name
	}
	namespace, err := i.Mapping.MetadataAccessor.Namespace(obj)
	if err != nil {
		if !ignoreError {
			return err
		}
	} else {
		i.Namespace = namespace
	}
	version, err := i.Mapping.MetadataAccessor.ResourceVersion(obj)
	if err != nil {
		if !ignoreError {
			return err
		}
	} else {
		i.ResourceVersion = version
	}
	i.Object = obj
	return nil
}
```

#### InfoListVisitor

InfoListVisitor  也属于 Visitor 类型。

```go
type InfoListVisitor []*Info

func (infos InfoListVisitor) Visit(fn VisitorFunc) error {
	var err error
	for _, i := range infos {
		err = fn(i, err)
	}
	return err
}

```



#### URLVisitor

URLVisitor 通过 URL 发起 http 请求下载资源，然后构建为 Info。

```go
type URLVisitor struct {
	URL *url.URL
	*StreamVisitor
	HttpAttemptCount int
}

func (v *URLVisitor) Visit(fn VisitorFunc) error {
	body, err := readHttpWithRetries(httpgetImpl, time.Second, v.URL.String(), v.HttpAttemptCount)
	if err != nil {
		return err
	}
	defer body.Close()
	v.StreamVisitor.Reader = body
	return v.StreamVisitor.Visit(fn)
}

```



#### DecoratedVisitor

DecoratedVisitor 在调用 Visitor 的 Visit 函数之前先调用装饰器。

```go
type DecoratedVisitor struct {
	visitor    Visitor
	decorators []VisitorFunc
}

func (v DecoratedVisitor) Visit(fn VisitorFunc) error {
	return v.visitor.Visit(func(info *Info, err error) error {
		if err != nil {
			return err
		}
		for i := range v.decorators {
            // 调用装饰器
			if err := v.decorators[i](info, nil); err != nil {
				return err
			}
		}
		return fn(info, nil)
	})
}
```



#### StreamVisitor

StreamVisitor 从 `io.Reader` 流中读取数据转换为 JSON 格式，然后通过 `runtime.Codec` 解码，进行schema检查，构建为 Info 对象。

```go
type StreamVisitor struct {
	io.Reader
	*mapper

	Source string
	Schema ContentValidator
}


func (v *StreamVisitor) Visit(fn VisitorFunc) error {
	d := yaml.NewYAMLOrJSONDecoder(v.Reader, 4096)
	for {
		ext := runtime.RawExtension{}
        // 解码
		if err := d.Decode(&ext); err != nil {
            ...
		}
            ...
        // 构建为 Info
		info, err := v.infoForData(ext.Raw, v.Source)
		if err != nil {
			if fnErr := fn(info, err); fnErr != nil {
				return fnErr
			}
			continue
		}
		if err := fn(info, nil); err != nil {
			return err
		}
	}
}
```



#### FileVisitor

FileVisitor 是对 StreamVisitor 的封装。 

```go
type FileVisitor struct {
	Path string
	*StreamVisitor
}
func (v *FileVisitor) Visit(fn VisitorFunc) error {
	var f *os.File
	if v.Path == constSTDINstr {
		f = os.Stdin
	} else {
		var err error
		f, err = os.Open(v.Path)
		if err != nil {
			return err
		}
		defer f.Close()
	}
	utf16bom := unicode.BOMOverride(unicode.UTF8.NewDecoder())
	v.StreamVisitor.Reader = transform.NewReader(f, utf16bom)
	return v.StreamVisitor.Visit(fn)
}
```

#### FlattenListVisitor

FlattenListVisitor 可以对列表中的每个元素进行处理。如果有错误发生，则返回。

```go

type FlattenListVisitor struct {
	visitor Visitor
	typer   runtime.ObjectTyper
	mapper  *mapper
}


func (v FlattenListVisitor) Visit(fn VisitorFunc) error {
	return v.visitor.Visit(func(info *Info, err error) error {
		if err != nil {
			return err
		}
		if info.Object == nil {
			return fn(info, nil)
		}
		if !meta.IsListType(info.Object) {
			return fn(info, nil)
		}

		items := []runtime.Object{}
		itemsToProcess := []runtime.Object{info.Object}

		for i := 0; i < len(itemsToProcess); i++ {
			currObj := itemsToProcess[i]
			if !meta.IsListType(currObj) {
				items = append(items, currObj)
				continue
			}
            // 提取列表
			currItems, err := meta.ExtractList(currObj)
			if err != nil {
				return err
			}
			if errs := runtime.DecodeList(currItems, v.mapper.decoder); len(errs) > 0 {
				return utilerrors.NewAggregate(errs)
			}
			itemsToProcess = append(itemsToProcess, currItems...)
		}

	  
		var preferredGVKs []schema.GroupVersionKind
		if info.Mapping != nil && !info.Mapping.GroupVersionKind.Empty() {
			preferredGVKs = append(preferredGVKs, info.Mapping.GroupVersionKind)
		}
		errs := []error{}
        // 对列表中每一个元素进行下一步处理
		for i := range items {
			item, err := v.mapper.infoForObject(items[i], v.typer, preferredGVKs)
			if err != nil {
				errs = append(errs, err)
				continue
			}
			if len(info.ResourceVersion) != 0 {
				item.ResourceVersion = info.ResourceVersion
			}
			if err := fn(item, nil); err != nil {
				errs = append(errs, err)
			}
		}
		return utilerrors.NewAggregate(errs)

	})
}
```

#### FilteredVisitor

FilteredVisitor 可以检查 Info 是否满足某些条件。如果满足条件，则往下执行，否则返回 err。

```go
type FilteredVisitor struct {
	visitor Visitor
	filters []FilterFunc
}
func NewFilteredVisitor(v Visitor, fn ...FilterFunc) Visitor {
	if len(fn) == 0 {
		return v
	}
	return FilteredVisitor{v, fn}
}
func (v FilteredVisitor) Visit(fn VisitorFunc) error {
	return v.visitor.Visit(func(info *Info, err error) error {
		if err != nil {
			return err
		}
		for _, filter := range v.filters {
			ok, err := filter(info, nil)
			if err != nil {
				return err
			}
			if !ok {
				return nil
			}
		}
		return fn(info, nil)
	})
}
```

#### ContinueOnErrorVisitor

ContinueOnErrorVisitor会收集子 Visitor 产生的错误，并返回。

```go
type ContinueOnErrorVisitor struct {
	Visitor
}
func (v ContinueOnErrorVisitor) Visit(fn VisitorFunc) error {
	errs := []error{}
	err := v.Visitor.Visit(func(info *Info, err error) error {
		if err != nil {
			errs = append(errs, err)
			return nil
		}
		// 此处传入fn的错误是nil
		if err := fn(info, nil); err != nil {
			errs = append(errs, err)
		}
		return nil
	})
	if err != nil {
		errs = append(errs, err)
	}
	if len(errs) == 1 {
		return errs[0]
	}
	return utilerrors.NewAggregate(errs)
}
```



#### Selector

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/selector.go](https://github.com/kubernetes/kubernetes/blob/v1.18.0/staging/src/k8s.io/cli-runtime/pkg/resource/selector.go)

Selector 也属于 Visitor 类型，用于 label 选择。

```go
// Selector is a Visitor for resources that match a label selector.
type Selector struct {
	Client        RESTClient
	Mapping       *meta.RESTMapping
	Namespace     string
	LabelSelector string
	FieldSelector string
	Export        bool
	LimitChunks   int64
}


// Visit implements Visitor and uses request chunking by default.
func (r *Selector) Visit(fn VisitorFunc) error {
	var continueToken string
	for {
		list, err := NewHelper(r.Client, r.Mapping).List(
			r.Namespace,
			r.ResourceMapping().GroupVersionKind.GroupVersion().String(),
			r.Export,
			&metav1.ListOptions{
				LabelSelector: r.LabelSelector,
				FieldSelector: r.FieldSelector,
				Limit:         r.LimitChunks,
				Continue:      continueToken,
			},
		)
		if err != nil {
			if errors.IsResourceExpired(err) {
				return err
			}
			if errors.IsBadRequest(err) || errors.IsNotFound(err) {
				if se, ok := err.(*errors.StatusError); ok {
					// modify the message without hiding this is an API error
					if len(r.LabelSelector) == 0 && len(r.FieldSelector) == 0 {
						se.ErrStatus.Message = fmt.Sprintf("Unable to list %q: %v", r.Mapping.Resource, se.ErrStatus.Message)
					} else {
						se.ErrStatus.Message = fmt.Sprintf("Unable to find %q that match label selector %q, field selector %q: %v", r.Mapping.Resource, r.LabelSelector, r.FieldSelector, se.ErrStatus.Message)
					}
					return se
				}
				if len(r.LabelSelector) == 0 && len(r.FieldSelector) == 0 {
					return fmt.Errorf("Unable to list %q: %v", r.Mapping.Resource, err)
				}
				return fmt.Errorf("Unable to find %q that match label selector %q, field selector %q: %v", r.Mapping.Resource, r.LabelSelector, r.FieldSelector, err)
			}
			return err
		}
		resourceVersion, _ := metadataAccessor.ResourceVersion(list)
		nextContinueToken, _ := metadataAccessor.Continue(list)
		info := &Info{
			Client:  r.Client,
			Mapping: r.Mapping,

			Namespace:       r.Namespace,
			ResourceVersion: resourceVersion,

			Object: list,
		}

		if err := fn(info, nil); err != nil {
			return err
		}
		if len(nextContinueToken) == 0 {
			return nil
		}
		continueToken = nextContinueToken
	}
}
```



### Result

Builder 的 `Do()` 可以返回 Result。现在让我们来看看Result的定义。

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/result.go ](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/resource/result.go#L37)

```go
// Result contains helper methods for dealing with the outcome of a Builder.
type Result struct {
	err     error
	visitor Visitor

	sources            []Visitor
	singleItemImplied  bool
	targetsSingleItems bool

	mapper       *mapper
	ignoreErrors []utilerrors.Matcher

	// populated by a call to Infos
	info []*Info
}

```

可以看到，Result 也包含一个 Visitor，及一个 info 表示[]*Info，所以 Result 提供了 Infos() 方法来获取Visitor的结果 Info 数组及 Object() 方法来获取Visitor的结果Obj(可能为List)。

#### Infos()

Info() 调用层层封装的 Visitor，然后收集所有 Info 并返回。

```go
// Infos returns an array of all of the resource infos retrieved via traversal.
// Will attempt to traverse the entire set of visitors only once, and will return
// a cached list on subsequent calls.
func (r *Result) Infos() ([]*Info, error) {
	if r.err != nil {
		return nil, r.err
	}
	if r.info != nil {
		return r.info, nil
	}

	infos := []*Info{}
	err := r.visitor.Visit(func(info *Info, err error) error {
		if err != nil {
			return err
		}
		infos = append(infos, info)
		return nil
	})
	err = utilerrors.FilterOut(err, r.ignoreErrors...)

	r.info, r.err = infos, err
	return infos, err
}

```

#### Object()

Object()先调用 Infos() 来获取 infos，然后从每个info中提取出Object组成ObjectList返回。

```go
func (r *Result) Object() (runtime.Object, error) {
	infos, err := r.Infos()
	if err != nil {
		return nil, err
	}

	versions := sets.String{}
	objects := []runtime.Object{}
	for _, info := range infos {
		if info.Object != nil {
			objects = append(objects, info.Object)
			versions.Insert(info.ResourceVersion)
		}
	}

	if len(objects) == 1 {
		if r.singular {
			return objects[0], nil
		}
		// if the item is a list already, don't create another list
		if meta.IsListType(objects[0]) {
			return objects[0], nil
		}
	}

	version := ""
	if len(versions) == 1 {
		version = versions.List()[0]
	}
	return &api.List{
		ListMeta: unversioned.ListMeta{
			ResourceVersion: version,
		},
		Items: objects,
	}, err
}
```



### Helper

在 Kubernetes中，Helper 一般都提供类似驱动的功能。Kubectl 的 helper 就是用来访问Client的驱动。一般来说，某个visitFunc 函数中会调用Helper的相关成员函数来完成具体请求。

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/helper.go ](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/resource/helper.go#L35)

```go
// Helper provides methods for retrieving or mutating a RESTful
// resource.
type Helper struct {
	// The name of this resource as the server would recognize it
	Resource string
	// A RESTClient capable of mutating this resource.
	RESTClient RESTClient
	// An interface for reading or writing the resource version of this
	// type.
	Versioner runtime.ResourceVersioner
	// True if the resource type is scoped to namespaces
	NamespaceScoped bool
}
```

Helper 实现了Get(), List(), Watch(), WatchSingle(), Delete(), Create(), Patch(), Replace()等方法，这些方法是对RESTClient的封装。



### Mapper

这里的Mapper是指kubectl中的Mapper，是对ObjectTyper, RESTMapper, ClientMapper和Decoder的封装。

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/resource/mapper.go ](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/cli-runtime/pkg/resource/mapper.go#L29)

```go
type Mapper struct {
	runtime.ObjectTyper
	meta.RESTMapper
	// 定义在/pkg/kubectl/resource/interfaces.go中
	// ClientMapper可以根据config和mapping通过调用ClientForMapping()生成RESTClient
	ClientMapper
	runtime.Decoder
}
```



#### Build Mapper

从`/pkg/kubectl/cmd/util/factory.go的NewBuilder()`函数说起

```go
func (f *factory) NewBuilder() *resource.Builder {
	mapper, typer := f.Object()
	// 此处有kubectl mapper的各项参数的定义
	/  其中Decoder为f.Decoder(true)
	return resource.NewBuilder(mapper, typer, resource.ClientMapperFunc(f.ClientForMapping), f.Decoder(true))
}
```



再来看`/pkg/kubectl/ressourcce/builder.go`中的`NewBuilder()`:

```go
// NewBuilder creates a builder that operates on generic objects.
func NewBuilder(mapper meta.RESTMapper, typer runtime.ObjectTyper, clientMapper ClientMapper, decoder runtime.Decoder) *Builder {
	return &Builder{
		// 把RESTMapper, ObjectTyper, ClientMapper, Decoder封装成kubectl的 Mapper
		mapper:        &Mapper{typer, mapper, clientMapper, decoder},
		requireObject: true,
	}
}
```



可以看出，Mapper的创建在 builder.go 中，但真正准备创建Mapper的其他结构体的地方还是在 factory.go 中。

- runtime.ObjectTyper: 由f.Object()生成；
- meta.RESTMapper: 由f.Object()生成；
- ClientMapper: resource.ClientMapperFunc(f.ClientForMapping)
- runtime.Decoder: f.Decoder(true)

#### f.Object()

Object() 返回一个RESTMapper及 api.Scheme。这里api.Scheme将传递给Typer。关于RESTMapper，现在只需知道存储了GVK和GVR的关系，可以通过RESTMapping()返回一个mapping表示GVK和Resource的关系。可以用mapping生成一个config，再生成Client。

```
func (f *factory) Object() (meta.RESTMapper, runtime.ObjectTyper) {
	// registered.RESTMapper()定义在/pkg/apimachinery/registerd/registered.go中
	mapper := registered.RESTMapper()
	// 生成discoveryClient
	discoveryClient, err := f.DiscoveryClient()
	if err == nil {
		// discoveryClient生成成功的情况下，mapper为一个FistHitRESTMapper
		mapper = meta.FirstHitRESTMapper{
			MultiRESTMapper: meta.MultiRESTMapper{
				discovery.NewDeferredDiscoveryRESTMapper(discoveryClient, registered.InterfacesFor),
				registered.RESTMapper(), // hardcoded fall back
			},
		}
	}

	// wrap with shortcuts
	mapper = NewShortcutExpander(mapper, discoveryClient)

	// wrap with output preferences
	cfg, err := f.clients.ClientConfigForVersion(nil)
	checkErrWithPrefix("failed to get client config: ", err)
	cmdApiVersion := unversioned.GroupVersion{}
	if cfg.GroupVersion != nil {
		cmdApiVersion = *cfg.GroupVersion
	}
	mapper = kubectl.OutputVersionMapper{RESTMapper: mapper, OutputVersions: []unversioned.GroupVersion{cmdApiVersion}}
	return mapper, api.Scheme
}
```



#### f.ClientForMapping()

CLientForMapping()可以依据mapping中的信息生成一个config，然后再生成RESTClient。

```go
// 依据mapping生成RESTClient
func (f *factory) ClientForMapping(mapping *meta.RESTMapping) (resource.RESTClient, error) {
	cfg, err := f.clientConfig.ClientConfig()
	if err != nil {
		return nil, err
	}
	if err := client.SetKubernetesDefaults(cfg); err != nil {
		return nil, err
	}
	gvk := mapping.GroupVersionKind
	switch gvk.Group {
	case federation.GroupName:
		mappingVersion := mapping.GroupVersionKind.GroupVersion()
		return f.clients.FederationClientForVersion(&mappingVersion)
	case api.GroupName:
		cfg.APIPath = "/api"
	default:
		cfg.APIPath = "/apis"
	}
	gv := gvk.GroupVersion()
	cfg.GroupVersion = &gv
	if registered.IsThirdPartyAPIGroupVersion(gvk.GroupVersion()) {
		cfg.NegotiatedSerializer = thirdpartyresourcedata.NewNegotiatedSerializer(api.Codecs, gvk.Kind, gv, gv)
	}
	// 定义在/pkg/client/restclient/config.go
	return restclient.RESTClientFor(cfg)
}
```



而 resource.ClientMapperFunc 定义在`/pkg/kubectl/resource/interfaces.go`中：

```
type ClientMapperFunc func(mapping *meta.RESTMapping) (RESTClient, error)

// ClientForMapping implements ClientMapper
func (f ClientMapperFunc) ClientForMapping(mapping *meta.RESTMapping) (RESTClient, error) {
	return f(mapping)
}
```



所以，调用ClientMapper的ClientForMapping()方法就相关于调用factory的ClientForMapping()方法。

#### f.Decoder()

Decoder()定义在`/pkg/kubectl/cmd/util/factory.go`中：

```go
func (f *factory) Decoder(toInternal bool) runtime.Decoder {
	var decoder runtime.Decoder
	if toInternal {
		// api.Codecs定义在pkg/api/register.go中/
		decoder = api.Codecs.UniversalDecoder()
	} else {
		decoder = api.Codecs.UniversalDeserializer()
	}
	return thirdpartyresourcedata.NewDecoder(decoder, "")
}
```



因为传入的toInternal为true，所以Decoder为api.Codecs.UniversalDecoder()。这里不再向下分析，只需知道该Decoder可以把相关版本的对象转换成内部版本的对象。

#### RESTMapping()

调用的RESTMapper的RESTMapping()

#### ClientForMapping()

调用的就是f.ClientForMapping()



### Printer

Printer可以对Kubernetes中的资源按一定格式进行打印输出，Printer主要供Kubectl get命令使用。目前Kubectl主要实现了JsonPrinter, YAMLPrinter, NamePrinter, TemplatePrinter, JSONPathPrinter, CustomColumnsPrinter, VersionedPrinter, HumanReadablePrinter。

代码路径：

[kubernetes/staging/src/k8s.io/cli-runtime/pkg/printers/interface.go ](https://github.com/kubernetes/kubernetes/blob/v1.18.0/staging/src/k8s.io/cli-runtime/pkg/printers/interface.go#L35)

```go
// ResourcePrinterFunc is a function that can print objects
type ResourcePrinterFunc func(runtime.Object, io.Writer) error

// PrintObj implements ResourcePrinter
func (fn ResourcePrinterFunc) PrintObj(obj runtime.Object, w io.Writer) error {
	return fn(obj, w)
}

// ResourcePrinter is an interface that knows how to print runtime objects.
type ResourcePrinter interface {
	// Print receives a runtime object, formats it and prints it to a writer.
	PrintObj(runtime.Object, io.Writer) error
}

// PrintOptions struct defines a struct for various print options
type PrintOptions struct {
	NoHeaders     bool
	WithNamespace bool
	WithKind      bool
	Wide          bool
	ShowLabels    bool
	Kind          schema.GroupKind
	ColumnLabels  []string

	SortBy string

	// indicates if it is OK to ignore missing keys for rendering an output template.
	AllowMissingKeys bool
}
```



#### JSONPrinter

JSONPrinter 可以以JSON的格式打印Object。JSONPrinter调用了json.MarshalIndent()来对Obj进行JSON格式化打印。json.MarshalIndent()函数的功能和Marshal一致，只是把Object格式化成人性化阅读的JSON，有点类似”| python -mjson.tool”的功能。

```go
// JSONPrinter is an implementation of ResourcePrinter which outputs an object as JSON.
type JSONPrinter struct {
}

func (p *JSONPrinter) AfterPrint(w io.Writer, res string) error {
	return nil
}

// PrintObj is an implementation of ResourcePrinter.PrintObj which simply writes the object to the Writer.
func (p *JSONPrinter) PrintObj(obj runtime.Object, w io.Writer) error {
	switch obj := obj.(type) {
	case *runtime.Unknown:
		var buf bytes.Buffer
		err := json.Indent(&buf, obj.Raw, "", "    ")
		if err != nil {
			return err
		}
		buf.WriteRune('\n')
		_, err = buf.WriteTo(w)
		return err
	}

	data, err := json.MarshalIndent(obj, "", "    ")
	if err != nil {
		return err
	}
	data = append(data, '\n')
	_, err = w.Write(data)
	return err
}

// TODO: implement HandledResources()
func (p *JSONPrinter) HandledResources() []string {
	return []string{}
}
```



调用例子：

```
kubectl get pods -o json
```



#### YAMLPrinter

YAMLPrinter可以以YAML的格式打印Object。YAMLPrinter通过调用yaml.Marshal()把Object转换成YAML格式并进行打印。

```go
// YAMLPrinter is an implementation of ResourcePrinter which outputs an object as YAML.
// The input object is assumed to be in the internal version of an API and is converted
// to the given version first.
type YAMLPrinter struct {
	version   string
	converter runtime.ObjectConvertor
}

func (p *YAMLPrinter) AfterPrint(w io.Writer, res string) error {
	return nil
}

// PrintObj prints the data as YAML.
func (p *YAMLPrinter) PrintObj(obj runtime.Object, w io.Writer) error {
	switch obj := obj.(type) {
	case *runtime.Unknown:
		data, err := yaml.JSONToYAML(obj.Raw)
		if err != nil {
			return err
		}
		_, err = w.Write(data)
		return err
	}

	// 把obj转成yaml格式
	output, err := yaml.Marshal(obj)
	if err != nil {
		return err
	}
	_, err = fmt.Fprint(w, string(output))
	return err
}
```



调用例子：

```
kubectl get pods -o yaml
```



#### NamePrinter

NamePrinter可以打印资源类型和名称：如pod/ubuntu-ssh-589933015-2lhgb。NamePrinter先获判断Object是否为列表，如果是列表，则递归调用PrintObj；否则先获取Object的name，然后获取Object的Kind，并转换成单数形式的GVR，然后返回。

```go
// NamePrinter is an implementation of ResourcePrinter which outputs "resource/name" pair of an object.
type NamePrinter struct {
	Decoder runtime.Decoder
	Typer   runtime.ObjectTyper
}

func (p *NamePrinter) AfterPrint(w io.Writer, res string) error {
	return nil
}

// PrintObj is an implementation of ResourcePrinter.PrintObj which decodes the object
// and print "resource/name" pair. If the object is a List, print all items in it.
func (p *NamePrinter) PrintObj(obj runtime.Object, w io.Writer) error {
	if meta.IsListType(obj) {
		items, err := meta.ExtractList(obj)
		if err != nil {
			return err
		}
		if errs := runtime.DecodeList(items, p.Decoder, runtime.UnstructuredJSONScheme); len(errs) > 0 {
			return utilerrors.NewAggregate(errs)
		}
		for _, obj := range items {
			if err := p.PrintObj(obj, w); err != nil {
				return err
			}
		}
		return nil
	}

	name := "<unknown>"
	// 获取name
	if acc, err := meta.Accessor(obj); err == nil {
		if n := acc.GetName(); len(n) > 0 {
			name = n
		}
	}

	if kind := obj.GetObjectKind().GroupVersionKind(); len(kind.Kind) == 0 {
		// this is the old code.  It's unnecessary on decoded external objects, but on internal objects
		// you may have to do it.  Tests are definitely calling it with internals and I'm not sure who else
		// is
		if gvks, _, err := p.Typer.ObjectKinds(obj); err == nil {
			// TODO: this is wrong, it assumes that meta knows about all Kinds - should take a RESTMapper
			_, resource := meta.KindToResource(gvks[0])
			fmt.Fprintf(w, "%s/%s\n", resource.Resource, name)
		} else {
			fmt.Fprintf(w, "<unknown>/%s\n", name)
		}

	} else {
		// TODO: this is wrong, it assumes that meta knows about all Kinds - should take a RESTMapper
		// 直接调用KindToResource()把GVK转换成GVR，并选用单数形式
		_, resource := meta.KindToResource(kind)
		fmt.Fprintf(w, "%s/%s\n", resource.Resource, name)
	}

	return nil
}
```



调用例子：

```
# kubectl get pods -o name
pod/nginx-1487191267-0t8x3
pod/ubuntu-ssh-589933015-2lhgb
```



#### TemplatePrinter

TemplatePrinter基于txt/template包实现。txt/template一般的用法为：
定义模板：

```go
tmpl, err := template.New("test").Parse("hello, {{.}}")
```



执行：

```
err = tmpl.Execute(os.Stdout, name)
```



TemplatePrinter定义如下：

```go
// TemplatePrinter is an implementation of ResourcePrinter which formats data with a Go Template.
// 调用text/template包
type TemplatePrinter struct {
	rawTemplate string
	template    *template.Template
}

func NewTemplatePrinter(tmpl []byte) (*TemplatePrinter, error) {
	t, err := template.New("output").
		Funcs(template.FuncMap{"exists": exists}).
		Parse(string(tmpl))
	if err != nil {
		return nil, err
	}
	return &TemplatePrinter{
		rawTemplate: string(tmpl),
		template:    t,
	}, nil
}

func (p *TemplatePrinter) AfterPrint(w io.Writer, res string) error {
	return nil
}

// PrintObj formats the obj with the Go Template.
func (p *TemplatePrinter) PrintObj(obj runtime.Object, w io.Writer) error {
	var data []byte
	var err error
	if unstructured, ok := obj.(*runtime.Unstructured); ok {
		data, err = json.Marshal(unstructured.Object)
	} else {
		data, err = json.Marshal(obj)

	}
	if err != nil {
		return err
	}

	out := map[string]interface{}{}
	if err := json.Unmarshal(data, &out); err != nil {
		return err
	}
	if err = p.safeExecute(w, out); err != nil {
		// It is way easier to debug this stuff when it shows up in
		// stdout instead of just stdin. So in addition to returning
		// a nice error, also print useful stuff with the writer.
		fmt.Fprintf(w, "Error executing template: %v. Printing more information for debugging the template:\n", err)
		fmt.Fprintf(w, "\ttemplate was:\n\t\t%v\n", p.rawTemplate)
		fmt.Fprintf(w, "\traw data was:\n\t\t%v\n", string(data))
		fmt.Fprintf(w, "\tobject given to template engine was:\n\t\t%+v\n\n", out)
		return fmt.Errorf("error executing template %q: %v", p.rawTemplate, err)
	}
	return nil
}

// TODO: implement HandledResources()
func (p *TemplatePrinter) HandledResources() []string {
	return []string{}
}
```



调用例子：

```
# kubectl get pods nginx-1487191267-0t8x3 -o go-template="The name is {{.metadata.name}}"
The name is nginx-1487191267-0t8x3
```



或者

```
# kubectl get pods nginx-1487191267-0t8x3 -o go-template-file=template 
The name is nginx-1487191267-0t8x3
```



其中`go-template-file=template`的template为文件，内容为:

```
The name is {{.metadata.name}}
```



#### JSONPathPrinter

JSONPathPrinter实现了一套匹配规则，详见https://kubernetes.io/docs/user-guide/jsonpath/。
jsonpath具体在`/pkg/util/jsonpath/jsonpath.go`中实现，具体分析此处略。

```go
// JSONPathPrinter is an implementation of ResourcePrinter which formats data with jsonpath expression.
type JSONPathPrinter struct {
	rawTemplate string
	*jsonpath.JSONPath
}

func NewJSONPathPrinter(tmpl string) (*JSONPathPrinter, error) {
	j := jsonpath.New("out")
	if err := j.Parse(tmpl); err != nil {
		return nil, err
	}
	return &JSONPathPrinter{tmpl, j}, nil
}

func (j *JSONPathPrinter) AfterPrint(w io.Writer, res string) error {
	return nil
}

// PrintObj formats the obj with the JSONPath Template.
func (j *JSONPathPrinter) PrintObj(obj runtime.Object, w io.Writer) error {
	var queryObj interface{} = obj
	if meta.IsListType(obj) {
		data, err := json.Marshal(obj)
		if err != nil {
			return err
		}
		queryObj = map[string]interface{}{}
		if err := json.Unmarshal(data, &queryObj); err != nil {
			return err
		}
	}

	if unknown, ok := obj.(*runtime.Unknown); ok {
		data, err := json.Marshal(unknown)
		if err != nil {
			return err
		}
		queryObj = map[string]interface{}{}
		if err := json.Unmarshal(data, &queryObj); err != nil {
			return err
		}
	}
	if unstructured, ok := obj.(*runtime.Unstructured); ok {
		queryObj = unstructured.Object
	}

	if err := j.JSONPath.Execute(w, queryObj); err != nil {
		fmt.Fprintf(w, "Error executing template: %v. Printing more information for debugging the template:\n", err)
		fmt.Fprintf(w, "\ttemplate was:\n\t\t%v\n", j.rawTemplate)
		fmt.Fprintf(w, "\tobject given to jsonpath engine was:\n\t\t%#v\n\n", queryObj)
		return fmt.Errorf("error executing jsonpath %q: %v\n", j.rawTemplate, err)
	}
	return nil
}

// TODO: implement HandledResources()
func (p *JSONPathPrinter) HandledResources() []string {
	return []string{}
}
```



调用例子：

```
# kubectl get pods -o jsonpath={.items[*].metadata.name}
nginx-1487191267-0t8x3 ubuntu-ssh-589933015-2lhgb
```



或者

```
# kubectl get pods -o jsonpath-file=template
nginx-1487191267-0t8x3 ubuntu-ssh-589933015-2lhgb
```



其中`jsonpath-file=template`的template为文件，内容为:

```
{.items[*].metadata.name}
```



#### CustomColumnsPrinter

CustomColumnsPrinter允许用户定义列名，是JSONPath的加强版。支持从命令行直接输入模板和从文件读取模板两种方式。

读取命令行模板的CustomColumnsPrinter生成函数如下：

```go
//***kubectl get pods -o custom-columns=Type:{.kind},Name:{.metadata.name}***//
func NewCustomColumnsPrinterFromSpec(spec string, decoder runtime.Decoder, noHeaders bool) (*CustomColumnsPrinter, error) {
	if len(spec) == 0 {
		return nil, fmt.Errorf("custom-columns format specified but no custom columns given")
	}
	// parts: [Type:{.kind} Name:{.metadata.name}]
	parts := strings.Split(spec, ",")
	columns := make([]Column, len(parts))
	for ix := range parts {
		colSpec := strings.Split(parts[ix], ":")
		if len(colSpec) != 2 {
			return nil, fmt.Errorf("unexpected custom-columns spec: %s, expected <header>:<json-path-expr>", parts[ix])
		}
		spec, err := massageJSONPath(colSpec[1])
		if err != nil {
			return nil, err
		}
		columns[ix] = Column{Header: colSpec[0], FieldSpec: spec}
	}
	return &CustomColumnsPrinter{Columns: columns, Decoder: decoder, NoHeaders: noHeaders}, nil
}
```



读取文件模板的CustomColumnsPrinter生成函数如下：

```go
// kubectl get pods -o custom-columns-file=/home/fankang/template
func NewCustomColumnsPrinterFromTemplate(templateReader io.Reader, decoder runtime.Decoder) (*CustomColumnsPrinter, error) {
	scanner := bufio.NewScanner(templateReader)
	if !scanner.Scan() {
		return nil, fmt.Errorf("invalid template, missing header line. Expected format is one line of space separated headers, one line of space separated column specs.")
	}
	// headers: [Type Name]
	headers := splitOnWhitespace(scanner.Text())

	if !scanner.Scan() {
		return nil, fmt.Errorf("invalid template, missing spec line. Expected format is one line of space separated headers, one line of space separated column specs.")
	}
	// specs: [{.kind} {.metadata.name}]
	specs := splitOnWhitespace(scanner.Text())

	// 如果headers和specs长度不一致，则直接返回
	if len(headers) != len(specs) {
		return nil, fmt.Errorf("number of headers (%d) and field specifications (%d) don't match", len(headers), len(specs))
	}

	columns := make([]Column, len(headers))
	for ix := range headers {
		spec, err := massageJSONPath(specs[ix])
		if err != nil {
			return nil, err
		}
		// 组装成Column
		columns[ix] = Column{
			Header:    headers[ix],
			FieldSpec: spec,
		}
	}
	// 返回CustomColumnsPrinter
	return &CustomColumnsPrinter{Columns: columns, Decoder: decoder, NoHeaders: false}, nil
}
```



CustomColumnsPrinter的PrintObj()方法如下，可以看出，调用了jsonpath.New()来解析模板。

```
func (s *CustomColumnsPrinter) PrintObj(obj runtime.Object, out io.Writer) error {
	w := tabwriter.NewWriter(out, columnwidth, tabwidth, padding, padding_character, flags)

	if !s.NoHeaders {
		headers := make([]string, len(s.Columns))
		for ix := range s.Columns {
			headers[ix] = s.Columns[ix].Header
		}
		fmt.Fprintln(w, strings.Join(headers, "\t"))
	}
	parsers := make([]*jsonpath.JSONPath, len(s.Columns))
	for ix := range s.Columns {
		parsers[ix] = jsonpath.New(fmt.Sprintf("column%d", ix))
		if err := parsers[ix].Parse(s.Columns[ix].FieldSpec); err != nil {
			return err
		}
	}

	if meta.IsListType(obj) {
		objs, err := meta.ExtractList(obj)
		if err != nil {
			return err
		}
		for ix := range objs {
			if err := s.printOneObject(objs[ix], parsers, w); err != nil {
				return err
			}
		}
	} else {
		if err := s.printOneObject(obj, parsers, w); err != nil {
			return err
		}
	}
	return w.Flush()
}
```



调用例子：

```
# kubectl get pods -o custom-columns=Type:{.kind},Name:{.metadata.name}
Type      Name
Pod       nginx-1487191267-0t8x3
Pod       ubuntu-ssh-589933015-2lhgb
```



或者

```
# kubectl get pods -o custom-columns-file=template
Type      Name
Pod       nginx-1487191267-0t8x3
Pod       ubuntu-ssh-589933015-2lhgb
```



其中`custom-columns-file=template`的template为文件，内容为:

```
Type              Name
{.kind}           {.metadata.name}
```



#### VersionedPrinter

VersionedPrinter是对其他Printer的封装，先把Object转换成对应版本的Object，然后再封装的Printer进行打印。

```
// VersionedPrinter takes runtime objects and ensures they are converted to a given API version
// prior to being passed to a nested printer.
type VersionedPrinter struct {
	printer   ResourcePrinter
	converter runtime.ObjectConvertor
	versions  []unversioned.GroupVersion
}

// NewVersionedPrinter wraps a printer to convert objects to a known API version prior to printing.
func NewVersionedPrinter(printer ResourcePrinter, converter runtime.ObjectConvertor, versions ...unversioned.GroupVersion) ResourcePrinter {
	return &VersionedPrinter{
		printer:   printer,
		converter: converter,
		versions:  versions,
	}
}

func (p *VersionedPrinter) AfterPrint(w io.Writer, res string) error {
	return nil
}

// PrintObj implements ResourcePrinter
func (p *VersionedPrinter) PrintObj(obj runtime.Object, w io.Writer) error {
	if len(p.versions) == 0 {
		return fmt.Errorf("no version specified, object cannot be converted")
	}
	converted, err := p.converter.ConvertToVersion(obj, unversioned.GroupVersions(p.versions))
	if err != nil {
		return err
	}
	return p.printer.PrintObj(converted, w)
}
```



version由`kubectl get pods --output-version='v1' -o yaml -w`的–output-version指定，但没什么作用，而且kubectl get代码中只有Watch会使用VersionedPrinter，所以还待更深入的研究。

#### HumanReadablePrinter

HumanReadablePrinter可以”人性化”地输出内容。HumanReadablePrinter中有handlerMap，handlerMap记录了待打印的对象到处理函数的映射关系。系统中每种资源都有对应的打印函数。

其中`kubectl -o wide`调用的也是HumanReadablePrinter。

```go
type HumanReadablePrinter struct {
	handlerMap   map[reflect.Type]*handlerEntry
	options      PrintOptions
	lastType     reflect.Type
	hiddenObjNum int
}

// NewHumanReadablePrinter creates a HumanReadablePrinter.
// 创建HumanReadablePrinter
func NewHumanReadablePrinter(options PrintOptions) *HumanReadablePrinter {
	printer := &HumanReadablePrinter{
		handlerMap: make(map[reflect.Type]*handlerEntry),
		options:    options,
	}
	printer.addDefaultHandlers()
	return printer
}

// 打印第一行标题
func (h *HumanReadablePrinter) printHeader(columnNames []string, w io.Writer) error {
	if _, err := fmt.Fprintf(w, "%s\n", strings.Join(columnNames, "\t")); err != nil {
		return err
	}
	return nil
}

// 打印Pod
func (h *HumanReadablePrinter) printPod(pod *api.Pod, w io.Writer, options PrintOptions) error {
	if err := printPodBase(pod, w, options); err != nil {
		return err
	}

	return nil
}

func printPodBase(pod *api.Pod, w io.Writer, options PrintOptions) error {
	name := formatResourceName(options.Kind, pod.Name, options.WithKind)
	namespace := pod.Namespace

	restarts := 0
	totalContainers := len(pod.Spec.Containers)
	readyContainers := 0

	reason := string(pod.Status.Phase)
	if pod.Status.Reason != "" {
		reason = pod.Status.Reason
	}

	initializing := false
	for i := range pod.Status.InitContainerStatuses {
		container := pod.Status.InitContainerStatuses[i]
		restarts += int(container.RestartCount)
		switch {
		case container.State.Terminated != nil && container.State.Terminated.ExitCode == 0:
			continue
		case container.State.Terminated != nil:
			// initialization is failed
			if len(container.State.Terminated.Reason) == 0 {
				if container.State.Terminated.Signal != 0 {
					reason = fmt.Sprintf("Init:Signal:%d", container.State.Terminated.Signal)
				} else {
					reason = fmt.Sprintf("Init:ExitCode:%d", container.State.Terminated.ExitCode)
				}
			} else {
				reason = "Init:" + container.State.Terminated.Reason
			}
			initializing = true
		case container.State.Waiting != nil && len(container.State.Waiting.Reason) > 0 && container.State.Waiting.Reason != "PodInitializing":
			reason = "Init:" + container.State.Waiting.Reason
			initializing = true
		default:
			reason = fmt.Sprintf("Init:%d/%d", i, len(pod.Spec.InitContainers))
			initializing = true
		}
		break
	}
	if !initializing {
		restarts = 0
		for i := len(pod.Status.ContainerStatuses) - 1; i >= 0; i-- {
			container := pod.Status.ContainerStatuses[i]

			restarts += int(container.RestartCount)
			if container.State.Waiting != nil && container.State.Waiting.Reason != "" {
				reason = container.State.Waiting.Reason
			} else if container.State.Terminated != nil && container.State.Terminated.Reason != "" {
				reason = container.State.Terminated.Reason
			} else if container.State.Terminated != nil && container.State.Terminated.Reason == "" {
				if container.State.Terminated.Signal != 0 {
					reason = fmt.Sprintf("Signal:%d", container.State.Terminated.Signal)
				} else {
					reason = fmt.Sprintf("ExitCode:%d", container.State.Terminated.ExitCode)
				}
			} else if container.Ready && container.State.Running != nil {
				readyContainers++
			}
		}
	}

	if pod.DeletionTimestamp != nil && pod.Status.Reason == node.NodeUnreachablePodReason {
		reason = "Unknown"
	} else if pod.DeletionTimestamp != nil {
		reason = "Terminating"
	}

	if options.WithNamespace {
		if _, err := fmt.Fprintf(w, "%s\t", namespace); err != nil {
			return err
		}
	}
	if _, err := fmt.Fprintf(w, "%s\t%d/%d\t%s\t%d\t%s",
		name,
		readyContainers,
		totalContainers,
		reason,
		restarts,
		translateTimestamp(pod.CreationTimestamp),
	); err != nil {
		return err
	}

	// -o wide则写入IP和NODE
	if options.Wide {
		nodeName := pod.Spec.NodeName
		podIP := pod.Status.PodIP
		if podIP == "" {
			podIP = "<none>"
		}
		if _, err := fmt.Fprintf(w, "\t%s\t%s",
			podIP,
			nodeName,
		); err != nil {
			return err
		}
	}

	if _, err := fmt.Fprint(w, AppendLabels(pod.Labels, options.ColumnLabels)); err != nil {
		return err
	}
	if _, err := fmt.Fprint(w, AppendAllLabels(options.ShowLabels, pod.Labels)); err != nil {
		return err
	}

	return nil
}
```



调用例子：

```
# kubectl get pods
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-7c96855774-c5xbp   1/1     Running   0          28s
nginx-deployment-7c96855774-lqzr4   1/1     Running   0          28s
nginx-deployment-7c96855774-txw7c   1/1     Running   0          28s
nginx-deployment-7c96855774-vjm6p   1/1     Running   0          28s
```



或者

```

# kubectl get pods -o wide
NAME                                READY   STATUS    RESTARTS   AGE   IP               NODE    NOMINATED NODE   READINESS GATES
nginx-deployment-7c96855774-c5xbp   1/1     Running   0          5s    10.100.166.154   node1   <none>           <none>
nginx-deployment-7c96855774-lqzr4   1/1     Running   0          5s    10.100.166.153   node1   <none>           <none>
nginx-deployment-7c96855774-txw7c   1/1     Running   0          5s    10.100.104.33    node2   <none>           <none>
nginx-deployment-7c96855774-vjm6p   1/1     Running   0          5s    10.100.104.34    node2   <none>           <none>
[root@master work]#

```

### Describer

Describer 是 Kubectl 上用来描述对象具体信息的，和`kubectl describe`配合使用。

代码路径：

[kubernetes/staging/src/k8s.io/kubectl/pkg/describe/interface.go](https://github.com/kubernetes/kubernetes/blob/v1.18.0/staging/src/k8s.io/kubectl/pkg/describe/interface.go#L43)

Describer( )函数，可以依据 mapping 生成合适的 Describer。

```go
type ResourceDescriber interface {
	Describe(namespace, name string, describerSettings DescriberSettings) (output string, err error)
}

```

可以看到，只要实现了Describe()的结构体都可以称为Describer。

所以，在`/pkg/kubectl/describer.go`中，实现了 PodDescriber, ReplicationControllerDescriber, SecretDescriber, ServiceDescriber, ServiceAccountDescriber, NodeDescriber, LimitRangeDescriber, ResourceQuotaDescriber, PersistentVolumeDescriber, PersistentVolumeClaimDescriber, NamespaceDescriber, EndpointsDescriber, ConfigMapDescriber, ReplicaSetDescriber, HorizontalPodAutoscalerDescriber, NetworkPolicyDescriber, HorizontalPodAutoscalerDescriber, DaemonSetDescriber, DeploymentDescriber, JobDescriber, IngressDescriber, JobDescriber, CronJobDescriber, StatefulSetDescriber, CertificateSigningRequestDescriber, StorageClassDescriber, PodDisruptionBudgetDescriber。

在实现Describer的结构体中，通常会嵌入一个clientset，用来在Describe()中获取具体的Object。比如说下面的ReplicationControllerDescriber。

```go
func (d *ReplicationControllerDescriber) Describe(namespace, name string, describerSettings DescriberSettings) (string, error) {
	rc := d.CoreV1().ReplicationControllers(namespace)
	pc := d.CoreV1().Pods(namespace)

	controller, err := rc.Get(context.TODO(), name, metav1.GetOptions{})
	if err != nil {
		return "", err
	}

	running, waiting, succeeded, failed, err := getPodStatusForController(pc, labels.SelectorFromSet(controller.Spec.Selector), controller.UID)
	if err != nil {
		return "", err
	}

	var events *corev1.EventList
	if describerSettings.ShowEvents {
		events, _ = d.CoreV1().Events(namespace).Search(scheme.Scheme, controller)
	}

	return describeReplicationController(controller, events, running, waiting, succeeded, failed)
}
```

#### DescriberMap

DescriberMap中记录了GK和Describer的关系。这里使用GK作为Key，因为GK足以标记一个类型。目前还不支持同名Kind出现在不同的Group(internal除外)中(否则resource无法找到合适的GVK)，所以感觉完全可以仅使用Kind作为Key。

```go
func describerMap(clientConfig *rest.Config) (map[schema.GroupKind]ResourceDescriber, error) {
	c, err := clientset.NewForConfig(clientConfig)
	if err != nil {
		return nil, err
	}

	m := map[schema.GroupKind]ResourceDescriber{
		{Group: corev1.GroupName, Kind: "Pod"}:                                    &PodDescriber{c},
		{Group: corev1.GroupName, Kind: "ReplicationController"}:                  &ReplicationControllerDescriber{c},
		{Group: corev1.GroupName, Kind: "Secret"}:                                 &SecretDescriber{c},
		{Group: corev1.GroupName, Kind: "Service"}:                                &ServiceDescriber{c},
		{Group: corev1.GroupName, Kind: "ServiceAccount"}:                         &ServiceAccountDescriber{c},
		{Group: corev1.GroupName, Kind: "Node"}:                                   &NodeDescriber{c},
		{Group: corev1.GroupName, Kind: "LimitRange"}:                             &LimitRangeDescriber{c},
		{Group: corev1.GroupName, Kind: "ResourceQuota"}:                          &ResourceQuotaDescriber{c},
		{Group: corev1.GroupName, Kind: "PersistentVolume"}:                       &PersistentVolumeDescriber{c},
		{Group: corev1.GroupName, Kind: "PersistentVolumeClaim"}:                  &PersistentVolumeClaimDescriber{c},
		{Group: corev1.GroupName, Kind: "Namespace"}:                              &NamespaceDescriber{c},
		{Group: corev1.GroupName, Kind: "Endpoints"}:                              &EndpointsDescriber{c},
		{Group: corev1.GroupName, Kind: "ConfigMap"}:                              &ConfigMapDescriber{c},
		{Group: corev1.GroupName, Kind: "PriorityClass"}:                          &PriorityClassDescriber{c},
		{Group: discoveryv1beta1.GroupName, Kind: "EndpointSlice"}:                &EndpointSliceDescriber{c},
		{Group: extensionsv1beta1.GroupName, Kind: "ReplicaSet"}:                  &ReplicaSetDescriber{c},
		{Group: extensionsv1beta1.GroupName, Kind: "NetworkPolicy"}:               &NetworkPolicyDescriber{c},
		{Group: extensionsv1beta1.GroupName, Kind: "PodSecurityPolicy"}:           &PodSecurityPolicyDescriber{c},
		{Group: autoscalingv2beta2.GroupName, Kind: "HorizontalPodAutoscaler"}:    &HorizontalPodAutoscalerDescriber{c},
		{Group: extensionsv1beta1.GroupName, Kind: "DaemonSet"}:                   &DaemonSetDescriber{c},
		{Group: extensionsv1beta1.GroupName, Kind: "Deployment"}:                  &DeploymentDescriber{c},
		{Group: extensionsv1beta1.GroupName, Kind: "Ingress"}:                     &IngressDescriber{c},
		{Group: networkingv1beta1.GroupName, Kind: "Ingress"}:                     &IngressDescriber{c},
		{Group: networkingv1beta1.GroupName, Kind: "IngressClass"}:                &IngressClassDescriber{c},
		{Group: batchv1.GroupName, Kind: "Job"}:                                   &JobDescriber{c},
		{Group: batchv1.GroupName, Kind: "CronJob"}:                               &CronJobDescriber{c},
		{Group: appsv1.GroupName, Kind: "StatefulSet"}:                            &StatefulSetDescriber{c},
		{Group: appsv1.GroupName, Kind: "Deployment"}:                             &DeploymentDescriber{c},
		{Group: appsv1.GroupName, Kind: "DaemonSet"}:                              &DaemonSetDescriber{c},
		{Group: appsv1.GroupName, Kind: "ReplicaSet"}:                             &ReplicaSetDescriber{c},
		{Group: certificatesv1beta1.GroupName, Kind: "CertificateSigningRequest"}: &CertificateSigningRequestDescriber{c},
		{Group: storagev1.GroupName, Kind: "StorageClass"}:                        &StorageClassDescriber{c},
		{Group: storagev1.GroupName, Kind: "CSINode"}:                             &CSINodeDescriber{c},
		{Group: policyv1beta1.GroupName, Kind: "PodDisruptionBudget"}:             &PodDisruptionBudgetDescriber{c},
		{Group: rbacv1.GroupName, Kind: "Role"}:                                   &RoleDescriber{c},
		{Group: rbacv1.GroupName, Kind: "ClusterRole"}:                            &ClusterRoleDescriber{c},
		{Group: rbacv1.GroupName, Kind: "RoleBinding"}:                            &RoleBindingDescriber{c},
		{Group: rbacv1.GroupName, Kind: "ClusterRoleBinding"}:                     &ClusterRoleBindingDescriber{c},
		{Group: networkingv1.GroupName, Kind: "NetworkPolicy"}:                    &NetworkPolicyDescriber{c},
		{Group: schedulingv1.GroupName, Kind: "PriorityClass"}:                    &PriorityClassDescriber{c},
	}

	return m, nil
}

```

所以来看来`/pkg/kubectl/describe.go`中的DescriberFor()函数：

```
// 返回合适的describer
func DescriberFor(kind schema.GroupKind, clientConfig *rest.Config) (ResourceDescriber, bool) {
	describers, err := describerMap(clientConfig)
	if err != nil {
		klog.V(1).Info(err)
		return nil, false
	}

	f, ok := describers[kind]
	return f, ok
}
```

函数的实现很简单，先调用describerMap()生成DescriberMap，然后找到对应kind的Describer。

