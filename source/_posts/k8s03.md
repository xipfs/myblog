---
title: 深入理解 Kubernetes 之 API server
date: 2020-05-27 15:04:05
author: Rootkit
top: false
mathjax: false
categories: Kubernetes
tags:
  - Kubernetes
---



# API server

## 简介

Kubernetes API server 为 api 对象验证并配置数据，包括 pods、 services、 replicationcontrollers 和其它 api 对象。API Server 提供 REST 操作和到集群共享状态的前端，所有其他组件通过它进行交互，是整个系统的数据总线和数据中心。

![](/images/2020/communication_paths.png)

Kubernetes 中的其它组件都不会和 etcd 进行交互，只有 API Server 可以和 etcd 进行交互,api-server 具有如下功能：

- 整个集群管理的API接口：所有对集群进行的查询和管理都是通过API 进行
- 集群内部各个模块之间通信的枢纽：所有模块之间并不会互相调用，而是通过和 API Serve r打交道完成这部分的工作
- 集群的安全控制:API Server 提供的验证和授权保证了整个集群的安全

## API server 工作原理

![](/images/2020/API_server.jpg)



### 声明式 API 设计



**描述资源版本信息**

```
/api/{version}/{resource}/{action}
```

上面是一个基础的 web url 通常我们都会为每个版本注册一个对应的 URL, 其中会包含很关键的两个信息即 version与 resource ,通过这两个信息,通常我们就可以知道这可能是某个资源的那个版本, 如果我们把后面的 action 也包裹进来,我们通常就可以知道对应的资源的那个具体操作

**Group组信息**

![](/images/2020/gvk.png)



我们通过 url 里面获取到资源的 GroupVersionKind 信息，如何将其映射为一个具体的类型呢？结合反射和map来做就可以了，我们通过url获取到对应想的GVK信息，然后在通过我们的映射表，就知道对应的模型是哪个，接下来就只需要进行转换就行了

![](/images/2020/parse_gvk.png)



#### RESTMapper

RESTMapper是一个interface，定义在[kubernetes/staging/src/k8s.io/apimachinery/pkg/api/meta/interfaces.go ](https://github.com/kubernetes/kubernetes/blob/9e991415386e4cf155a24b1da15becaa390438d8/staging/src/k8s.io/apimachinery/pkg/api/meta/interfaces.go#L113)中:

```go
type RESTMapper interface {
	KindFor(resource schema.GroupVersionResource) (schema.GroupVersionKind, error)
	KindsFor(resource schema.GroupVersionResource) ([]schema.GroupVersionKind, error)
	ResourceFor(input schema.GroupVersionResource) (schema.GroupVersionResource, error)
	ResourcesFor(input schema.GroupVersionResource) ([]schema.GroupVersionResource, error)
	RESTMapping(gk schema.GroupKind, versions ...string) (*RESTMapping, error)
	RESTMappings(gk schema.GroupKind, versions ...string) ([]*RESTMapping, error)
	ResourceSingularizer(resource string) (singular string, err error)
}
```

RESTMapper 映射是指 GVR(GroupVersionResource) 和 GVK(GroupVersionKind) 的关系，可以通过 GVR 找到合适的 GVK，并可以通过GVK 生成一个 RESTMapping。

#### RESTMapping

与 RESTMapper 定义在同一个文件中

```go
type RESTMapping struct {
	Resource schema.GroupVersionResource
	GroupVersionKind schema.GroupVersionKind
	Scope RESTScope
}
```

RESTMapping 包含 Resource 名称，及其对应的 GVK，还有一个Scope(标明资源是否为root或者namespaced)，

#### RESTScope

与 RESTMapper 定义在同一个文件中

```go
type RESTScope interface {
	Name() RESTScopeName
}
```

表明作用域可以是基于 namespace 的，也可以是基于集群的。 如果是基于 namespace 的。则API格式为：`/apis/{group}/v1/namespaces/{namespace}/{spec.names.plural}/…` 如果是基于 cluster 的。则API格式为：`/apis/{group}/v1/{spec.names.plural}/…` 上文创建的 CRD 的 API 则为：`/apis/xxx.com/v1/namespaces/{namespace}/tasks`

#### DefaultRESTMapper

代码路径：[kubernetes/staging/src/k8s.io/apimachinery/pkg/api/meta/restmapper.go ](https://github.com/kubernetes/kubernetes/blob/9e991415386e4cf155a24b1da15becaa390438d8/staging/src/k8s.io/apimachinery/pkg/api/meta/restmapper.go#L57)

DefaultRESTMapper 实现了 RESTMapper interface。

```go
// DefaultRESTMapper 中的 resource 是指 GVR，kind 是指 GVK
// singular和 Plural 都是 GVR
type DefaultRESTMapper struct {
	defaultGroupVersions []schema.GroupVersion

	resourceToKind       map[schema.GroupVersionResource]schema.GroupVersionKind
	kindToPluralResource map[schema.GroupVersionKind]schema.GroupVersionResource
	kindToScope          map[schema.GroupVersionKind]RESTScope
	singularToPlural     map[schema.GroupVersionResource]schema.GroupVersionResource
	pluralToSingular     map[schema.GroupVersionResource]schema.GroupVersionResource
}

```

现在来详细分析DefaultRESTMapper的字段的涵义。

- defaultGroupVersions: 默认的GroupVersion，如v1，apps/v1beta1等，一般一个 DefaultRESTMapper只设一个默认的GroupVersion；
- resourceToKind：GVR(单数,复数)到GVK的map；
- kindToPluralResource：GVK到GVR(复数)的map；
- kindToScope：GVK到Scope的map；
- singularToPlural：GVR(单数)到GVR(复数)的map；
- pluralToSingular:  GVR(单数)到GVR(复数)的map；

RESTMapper 可以从 GVR 获取 GVK，并生成一个 RESTMapping 来处理该 GVR。RESTMapping 中有Resource名称，GVK，Scope等和GVR有关的信息

#### Scheme

![](/images/2020/scheme.png)

如果说 RESTMapper 管理的是 GVR 和 GVK 的关系，那么 Scheme 管理的就是 GVK 和 Type 的关系。系统中所有的Type都要注册到Scheme中，当然目前系统只有一个Scheme，即api.Scheme，定义在[kubernetes/staging/src/k8s.io/client-go/kubernetes/scheme/register.go ](https://github.com/kubernetes/kubernetes/blob/565566f4b2dae269bec108624fe28d3462d6ae2a/staging/src/k8s.io/client-go/kubernetes/scheme/register.go#L69)中：

```go
var Scheme = runtime.NewScheme()
```

Scheme 定义在[kubernetes/staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go ](https://github.com/kubernetes/kubernetes/blob/565566f4b2dae269bec108624fe28d3462d6ae2a/staging/src/k8s.io/apimachinery/pkg/runtime/scheme.go#L47)

```go
type Scheme struct {
	// versionMap allows one to figure out the go type of an object with
	// the given version and name.
	gvkToType map[schema.GroupVersionKind]reflect.Type

	// typeToGroupVersion allows one to find metadata for a given go object.
	// The reflect.Type we index by should *not* be a pointer.
	typeToGVK map[reflect.Type][]schema.GroupVersionKind

	// unversionedTypes are transformed without conversion in ConvertToVersion.
	unversionedTypes map[reflect.Type]schema.GroupVersionKind

	// unversionedKinds are the names of kinds that can be created in the context of any group
	// or version
	// TODO: resolve the status of unversioned types.
	unversionedKinds map[string]reflect.Type

	// Map from version and resource to the corresponding func to convert
	// resource field labels in that version to internal version.
	fieldLabelConversionFuncs map[schema.GroupVersionKind]FieldLabelConversionFunc

	// defaulterFuncs is an array of interfaces to be called with an object to provide defaulting
	// the provided object must be a pointer.
	defaulterFuncs map[reflect.Type]func(interface{})

	// converter stores all registered conversion functions. It also has
	// default converting behavior.
	converter *conversion.Converter

	// versionPriority is a map of groups to ordered lists of versions for those groups indicating the
	// default priorities of these versions as registered in the scheme
	versionPriority map[string][]string

	// observedVersions keeps track of the order we've seen versions during type registration
	observedVersions []schema.GroupVersion

	// schemeName is the name of this scheme.  If you don't specify a name, the stack of the NewScheme caller will be used.
	// This is useful for error reporting to indicate the origin of the scheme.
	schemeName string
}
```

可以看出，Scheme除了管理 GVK 和 Type 的关系，还管理有默认设置函数，并聚合了converter及cloner。我们来详细看下每个字段的含义：

- gvkToType: 存储 gvk 和 Type 的关系，一个 gvk 只能对应一个 Type；
- typeToGVK：存储 Type 和 gvk 的关系，一个 type 可能对应多个 GVK；
- unversionedTypes：记录 unversioned 的 Type 和 GVK 的关系，unversioned 无需版本转换；
- unversionedKinds：记录 unversioned 的 GVK 和 Type 的关系；
- fieldLabelConversionFuncs：管理 field selector 的转换，如旧版本v1的 spec.host 需要转换成spec.nodeName (详见在[kubernetes/pkg/apis/core/v1/conversion.go](https://github.com/kubernetes/kubernetes/blob/f221dbb91bde0d447226a7f15b7c4301ddd161c6/pkg/apis/core/v1/conversion.go#L33)中的addConversionFuncs()函数)；

```go
	func(label, value string) (string, string, error) {
			switch label {
			case "metadata.name",
				"metadata.namespace",
				"spec.nodeName",
				"spec.restartPolicy",
				"spec.schedulerName",
				"spec.serviceAccountName",
				"status.phase",
				"status.podIP",
				"status.podIPs",
				"status.nominatedNodeName":
				return label, value, nil
			case "spec.host":
				return "spec.nodeName", value, nil
			default:
				return "", "", fmt.Errorf("field label not supported: %s", label)
			}
		},
```



- defaulterFuncs：存储 Type及其对应的默认值设置函数；

- converter：用来转换不同版本的结构体值；

  

Kubernetes内部组件的流通的结构体值使用的是内部版本，所有的外部版本都要向内部版本进行转换；内部版本必须转换成外部版本才能进行输出。外部版本之间不能直接转换。从 Scheme 的定义可以看出，Scheme 也是 converter。

#### Converter

Converter可以完成不同结构体之间的转换。在Kubernetes中，Converter用来把一个版本的object转换成其他版本的object，转换函数需要通过注册的方式添加到Converter中。

![](/images/2020/covert.png)

先来看下Converter的定义，Converter定义在[kubernetes/staging/src/k8s.io/apimachinery/pkg/conversion/converter.go](https://github.com/kubernetes/kubernetes/blob/775feed217bf48035cb66bb7214a6c66385c73f7/staging/src/k8s.io/apimachinery/pkg/conversion/converter.go#L50)中：

```go
type Converter struct {
	// Map from the conversion pair to a function which can
	// do the conversion.
	conversionFuncs          ConversionFuncs
	generatedConversionFuncs ConversionFuncs

	// Set of conversions that should be treated as a no-op
	ignoredConversions        map[typePair]struct{}
	ignoredUntypedConversions map[typePair]struct{}

	// This is a map from a source field type and name, to a list of destination
	// field type and name.
	structFieldDests map[typeNamePair][]typeNamePair

	// Allows for the opposite lookup of structFieldDests. So that SourceFromDest
	// copy flag also works. So this is a map of destination field name, to potential
	// source field name and type to look for.
	structFieldSources map[typeNamePair][]typeNamePair

	// Map from an input type to a function which can apply a key name mapping
	inputFieldMappingFuncs map[reflect.Type]FieldMappingFunc

	// Map from an input type to a set of default conversion flags.
	inputDefaultFlags map[reflect.Type]FieldMatchingFlags

	// If non-nil, will be called to print helpful debugging info. Quite verbose.
	Debug DebugLogger

	// nameFunc is called to retrieve the name of a type; this name is used for the
	// purpose of deciding whether two types match or not (i.e., will we attempt to
	// do a conversion). The default returns the go type name.
	nameFunc func(t reflect.Type) string
}

```

Converter结构体的字段涵义如下：

- conversionFuncs: 普通转换函数，通过 RegisterConversionFunc() 方法进行注册；
- generatedConversionFuncs: 自动生成的转换函数，通过 RegisterGeneratedConversionFunc() 方法进行注册；
- genericConversions：通用转换函数，优化级最高的转换函数，可以理解为转换的快速通道，通过AddGenericConversionFunc()方法进行注册；
- ignoredConversions：需要忽略的转换，如果两个结构体之间不允许转换，则通过RegisterIgnoredConversion()方法进行注册；
- structFieldDests：源结构体中字段到目标结构体中的字段的映射关系，通过SetStructFieldCopy()方法进行注册；
- structFieldSources：与 structFieldDests 相反，是目的结构体中字段到源结构体中的字段的映射关系，通过SetStructFieldCopy() 方法进行注册；
- defaultingFuncs：设置结构体值的默认值，通过RegisterDefaultingFunc()方法进行注册；
- inputFieldMappingFuncs：
- inputDefaultFlags：
- nameFunc：获取结构体名称的函数。

Converter的生成方法如下，只要传入NameFunc 即可：

```go
func NewConverter(nameFn NameFunc) *Converter {
	c := &Converter{
		conversionFuncs:           NewConversionFuncs(),
		generatedConversionFuncs:  NewConversionFuncs(),
		ignoredConversions:        make(map[typePair]struct{}),
		ignoredUntypedConversions: make(map[typePair]struct{}),
		nameFunc:                  nameFn,
		structFieldDests:          make(map[typeNamePair][]typeNamePair),
		structFieldSources:        make(map[typeNamePair][]typeNamePair),

		inputFieldMappingFuncs: make(map[reflect.Type]FieldMappingFunc),
		inputDefaultFlags:      make(map[reflect.Type]FieldMatchingFlags),
	}
	c.RegisterUntypedConversionFunc(
		(*[]byte)(nil), (*[]byte)(nil),
		func(a, b interface{}, s Scope) error {
			return Convert_Slice_byte_To_Slice_byte(a.(*[]byte), b.(*[]byte), s)
		},
	)
	return c
}
```

关于NameFunc，只要实现返回一个结构体的“名字”就行，如：

```go
var DefaultNameFunc = func(t reflect.Type) string { return t.Name() }
```

##### ConversionFuncs

在Converter的字段中，不管是 conversionFuncs，还是 generatedConversionFuncs，都是结构体ConversionFuncs。结构体 ConversionFuncs 用来管理转换函数

```go
type typePair struct {
	source reflect.Type
	dest   reflect.Type
}

type ConversionFuncs struct {
	fns map[typePair]reflect.Value
}
```

在ConversionFuncs结构体中，只有一个字段`fns map[typePair]reflect.Value`，即{source, dest}到转换函数的映射表。

##### Scope

Scope是一个interface，所以我们来分析其实现者scope。

scope包含了递归转换中需要的一些内容。

```go
type Scope interface {
	// Call Convert to convert sub-objects. Note that if you call it with your own exact
	// parameters, you'll run out of stack space before anything useful happens.
	Convert(src, dest interface{}, flags FieldMatchingFlags) error

	// SrcTags and DestTags contain the struct tags that src and dest had, respectively.
	// If the enclosing object was not a struct, then these will contain no tags, of course.
	SrcTag() reflect.StructTag
	DestTag() reflect.StructTag

	// Flags returns the flags with which the conversion was started.
	Flags() FieldMatchingFlags

	// Meta returns any information originally passed to Convert.
	Meta() *Meta
}
```

来看scope的字段：

- converter：scope包含一个converter，以方便递归转换；
- meta：元数据
- flags：转换时字段的策略，定义如下，可以使用IsSet()方法判断对应的flag是否被设置。
  其中：
  DestFromSource表示循环目标结构体字段，寻找合适的源结构体字段；
  SourceToDest表示循环源结构体字段，寻找合适的目标结构体字段；
  IgnoreMissingFields表示如果未找到合适的目标不报错；
  AllowDifferentFieldTypeNames表示允许源结构体和目标结构体不同的类型相匹配。

+ SrcTag, DestTag：字段信息

convert() 的流程如下：

1. 获取源和目标的类型；
2. 设置源的默认值；
3. 判断是否在ignoredConversions中；
4. 尝试从conversionFuncs中获取转换函数进行转换；
5. 尝试从generatedConversionFuncs中获取转换函数进行转换；

Converter先使用genericConversionFunc进行转换，如果不成功，再使用conversionFunc进行转换，如果不成功，再按 generatedConversionFunc 进行转换，如果不成功，最后交由DefaultConvert()转换。

DefaultConvert()中如果转换类型是简单类型，则直接转换；如果是结构体，则先看是否有字段关系定义，如果有，则按map定义的来，否则按同名转换原则进行转换；其他的类型也有相应的方法进行转换。

### 总结

![](/images/2020/api.png)





## API server 工作流程

![](/images/2020/api-server-arch.png)



### API server 服务

![](/images/2020/api-server-serve.png)

整个程序的基本过程为：

- 命令行参数解析，参数存储在ServerRunOptions
- 基于ServerRunOptions构建genericapiserver.Config
- 构建master.Config
- 构建apiextensionserver.Config，并创建API Extension Server
- 构建Master（API Server），把API Extension Server作为代理服务，这样它会融合API Extension Server的服务
- 构建Aggregator，把Master作为代理服务
- 启动http非安全服务
- 执行Aggregator的Run，启动Https安全服务



#### APIExtensionsServer

`APIExtensionsServer`最先初始化，在调用链的末尾, 处理CR、CRD相关资源.

其中包含的 controller 以及功能如下所示：

1. openapiController：将 crd 资源的变化同步至提供的 OpenAPI 文档，可通过访问 /openapi/v2 进行查看；
2. crdController：负责将 crd 信息注册到 apiVersions 和 apiResources 中，两者的信息可通过 ` kubectl api-versions` 和  `kubectl api-resources` 查看；
3. namingController：检查 crd obj 中是否有命名冲突，可在 crd .status.conditions 中查看；
4. establishingController：检查 crd 是否处于正常状态，可在 crd .status.conditions 中查看；
5. nonStructuralSchemaController：检查 crd obj 结构是否正常，可在 crd .status.conditions 中查看；
6. apiApprovalController：检查 crd 是否遵循 kubernetes API 声明策略，可在 crd .status.conditions 中查看；
7. finalizingController：类似于 finalizes 的功能，与 CRs 的删除有关；



#### KubeAPIServer

KubeAPIServer 主要是提供对 API Resource 的操作请求，为 kubernetes 中众多 API 注册路由信息，暴露 RESTful API 并且对外提供 kubernetes service，使集群中以及集群外的服务都可以通过 RESTful API 操作 kubernetes 中的资源。

与`APIExtensionsServer`，`KubeAPIServer`初始化流程如下

1. `CreateKubeAPIServer`调用`kubeAPIServerConfig.Complete().New`来初始化
2. `New`函数创建默认的`apigroup`(pod,deployment等内部资源), 调用`InstallAPIs`注册
3. 启动相关controller, 加入到`poststarthook`

#### AggregatorServer

`Aggregator`通过`APIServices`对象关联到某个`Service`来进行请求的转发，其关联的`Service`类型进一步决定了请求转发形式。`Aggregator`包括一个`GenericAPIServer`和维护自身状态的`Controller`。其中 `GenericAPIServer`主要处理`apiregistration.k8s.io`组下的`APIService`资源请求。

`Aggregator`除了处理资源请求外还包含几个controller：

1. apiserviceRegistrationController：负责`APIServices`中资源的注册与删除；
2. availableConditionController：维护`APIServices`的可用状态，包括其引用`Service`是否可用等；
3. autoRegistrationController：用于保持API中存在的一组特定的`APIServices`；
4. crdRegistrationController：负责将`CRD GroupVersions`自动注册到`APIServices`中；
5. openAPIAggregationController：将`APIServices`资源的变化同步至提供的`OpenAPI`文档；
   kubernetes中的一些附加组件，比如metrics-server就是通过Aggregator的方式进行扩展的，实际环境中可以通过使用apiserver-builder工具轻松以Aggregator的扩展方式创建自定义资源。

初始化AggregatorServer的主要逻辑为：

1. 调用`aggregatorConfig.Complete().NewWithDelegate`创建`aggregatorServer`
2. 初始化`crdRegistrationController`和`autoRegistrationController`，`crdRegistrationController`负责注册CRD，`autoRegistrationController`负责将 CRD 对应的 APIServices自动注册到apiserver中，CRD 创建后可通过`kubectl get apiservices`查看是否注册到 apiservices中
3. 将`autoRegistrationController`和`crdRegistrationController`加入到PostStartHook中

API Server 的调用链，大体如下 `DefaultHandlerChain->{handler/crdhandler/proxy}->admission->validation->etcd`

1. 请求进入时，会经过`defaultchain`做一些认证鉴权工作
2. 然后通过`route`执行对应的handler，如果为aggration api, 将直接转发请求到对应service
3. handler处理完，经过admission与validation，做一些修改和检查，用户在这部分可以自定义webhook
4. 最后存入etcd



#### API server 启动过程

代码路径：

[kubernetes/cmd/kube-apiserver/apiserver.go](https://github.com/kubernetes/kubernetes/blob/v1.18.0/cmd/kube-apiserver/apiserver.go)

调用链：

```
main() -> app.NewAPIServerCommand() -> Run()->
```

```go
func NewAPIServerCommand() *cobra.Command {
    s := options.NewServerRunOptions()
    cmd := &cobra.Command{
        Use: "kube-apiserver",
        Long: `The Kubernetes API server validates and configures data
for the api objects which include pods, services, replicationcontrollers, and
others. The API Server services REST operations and provides the frontend to the
cluster's shared state through which all other components interact.`,
        Run: func(cmd *cobra.Command, args []string) {
            verflag.PrintAndExitIfRequested()

            stopCh := server.SetupSignalHandler()
            if err := Run(s, stopCh); err != nil {
                fmt.Fprintf(os.Stderr, "%v\n", err)
                os.Exit(1)
            }
        },
    }
    s.AddFlags(cmd.Flags())

    return cmd
}
```

APIServer的启动参数存储在ServerRunOptions中，启动参数基于命令行参数进行解析。
 cobra框架会自动分析命令行参数，命令行参数的解析是由s.AddFlag(cmd.Flags())中预先定义好的。在AddFlags方法中。

```go
// AddFlags adds flags for a specific APIServer to the specified FlagSet
func (s *ServerRunOptions) AddFlags(fs *pflag.FlagSet) {
    // Add the generic flags.
    s.GenericServerRunOptions.AddUniversalFlags(fs)
    s.Etcd.AddFlags(fs)
    s.SecureServing.AddFlags(fs)
    s.InsecureServing.AddFlags(fs)
    s.InsecureServing.AddDeprecatedFlags(fs)
    s.Audit.AddFlags(fs)
    s.Features.AddFlags(fs)
    s.Authentication.AddFlags(fs)
    s.Authorization.AddFlags(fs)
    s.CloudProvider.AddFlags(fs)
    s.StorageSerialization.AddFlags(fs)
    s.APIEnablement.AddFlags(fs)
    s.Admission.AddFlags(fs)

       ......   
    fs.BoolVar(&s.EnableAggregatorRouting, "enable-aggregator-routing", s.EnableAggregatorRouting,
        "Turns on aggregator routing requests to endoints IP rather than cluster IP.")

}
```

最终，我们会执行Command.Execute方法启动程序，它会首先解析参数，然后执行Run方法。

```go
// Run runs the specified APIServer.  This should never exit.
func Run(completeOptions completedServerRunOptions, stopCh <-chan struct{}) error {
	// To help debugging, immediately log version
	klog.Infof("Version: %+v", version.Get())

	server, err := CreateServerChain(completeOptions, stopCh)
	if err != nil {
		return err
	}
	prepared, err := server.PrepareRun()
	if err != nil {
		return err
	}

	return prepared.Run(stopCh)
}
```

**构建服务器调用链**

在上面的Run方法中，CreateServerChain 负责构建服务器链，最终返回 aggregatorServer ，：API Server主要工作都在CreateServerChain中完成的。

```go
// CreateServerChain creates the apiservers connected via delegation.
func CreateServerChain(completedOptions completedServerRunOptions, stopCh <-chan struct{}) (*aggregatorapiserver.APIAggregator, error) {
    // 如果指定了SSHUser参数，CreateNodeDialer用于创建连接本机节点的相关传输方法和网络建立方法
    // 所以与本机是通过SSH隧道交互的。通常情况下，我们是没有设置SSHUser参数的。
	nodeTunneler, proxyTransport, err := CreateNodeDialer(completedOptions)
	if err != nil {
		return nil, err
	}

	kubeAPIServerConfig, insecureServingInfo, serviceResolver, pluginInitializer, err := CreateKubeAPIServerConfig(completedOptions, nodeTunneler, proxyTransport)
	if err != nil {
		return nil, err
	}

	// If additional API servers are added, they should be gated.
	apiExtensionsConfig, err := createAPIExtensionsConfig(*kubeAPIServerConfig.GenericConfig, kubeAPIServerConfig.ExtraConfig.VersionedInformers, pluginInitializer, completedOptions.ServerRunOptions, completedOptions.MasterCount,
		serviceResolver, webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, kubeAPIServerConfig.GenericConfig.EgressSelector, kubeAPIServerConfig.GenericConfig.LoopbackClientConfig))
	if err != nil {
		return nil, err
	}
	apiExtensionsServer, err := createAPIExtensionsServer(apiExtensionsConfig, genericapiserver.NewEmptyDelegate())
	if err != nil {
		return nil, err
	}

	kubeAPIServer, err := CreateKubeAPIServer(kubeAPIServerConfig, apiExtensionsServer.GenericAPIServer)
	if err != nil {
		return nil, err
	}

	// aggregator comes last in the chain
	aggregatorConfig, err := createAggregatorConfig(*kubeAPIServerConfig.GenericConfig, completedOptions.ServerRunOptions, kubeAPIServerConfig.ExtraConfig.VersionedInformers, serviceResolver, proxyTransport, pluginInitializer)
	if err != nil {
		return nil, err
	}
	aggregatorServer, err := createAggregatorServer(aggregatorConfig, kubeAPIServer.GenericAPIServer, apiExtensionsServer.Informers)
	if err != nil {
		// we don't need special handling for innerStopCh because the aggregator server doesn't create any go routines
		return nil, err
	}

	if insecureServingInfo != nil {
		insecureHandlerChain := kubeserver.BuildInsecureHandlerChain(aggregatorServer.GenericAPIServer.UnprotectedHandler(), kubeAPIServerConfig.GenericConfig)
		if err := insecureServingInfo.Serve(insecureHandlerChain, kubeAPIServerConfig.GenericConfig.RequestTimeout, stopCh); err != nil {
			return nil, err
		}
	}

	return aggregatorServer, nil
}
```

CreateServerChain完成了主要的流程，里面有几个步骤比较特殊，这里分别讲解





#### GenericAPIServer

调用链：

```
main() -> app.NewAPIServerCommand() -> Run()->
server.PrepareRun()-> s.GenericAPIServer.PrepareRun()
```

GenericAPIServer可以理解为Kubernetes中提供API服务的结构体。

代码路径：

[kubernetes/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go ](https://github.com/kubernetes/kubernetes/blob/9d3406c27b581c0961ac5871f6893f838d59b10c/staging/src/k8s.io/apiserver/pkg/server/genericapiserver.go)

```go
type GenericAPIServer struct {
	// discoveryAddresses is used to build cluster IPs for discovery.
	discoveryAddresses discovery.Addresses
...
	// healthz checks
	healthzLock            sync.Mutex
	healthzChecks          []healthz.HealthChecker
	healthzChecksInstalled bool
...
	maxRequestBodyBytes int64
}

```

如何生成 GenericAPIServer 

调用路径：

```
main() -> app.NewAPIServerCommand() -> Run()->
CreateServerChain()->CreateKubeAPIServer()->
kubeAPIServerConfig.Complete().New(delegateAPIServer)->
c.GenericConfig.New("kube-apiserver", delegationTarget)
```

```go
func (c completedConfig) New(name string, delegationTarget DelegationTarget) (*GenericAPIServer, error) {
...
	handlerChainBuilder := func(handler http.Handler) http.Handler {
		return c.BuildHandlerChainFunc(handler, c.Config)
	}
	apiServerHandler := NewAPIServerHandler(name, c.Serializer, handlerChainBuilder, delegationTarget.UnprotectedHandler())

	s := &GenericAPIServer{
		discoveryAddresses:         c.DiscoveryAddresses,
		....
	}
...
	
    // 安装特殊功能的路径
	installAPI(s, c.Config)
...
	return s, nil
}

```



#### Master

Master的本质就是一个GenericAPIServer，定义在[kubernetes/pkg/master/master.go](https://github.com/kubernetes/kubernetes/blob/master/pkg/master/master.go)中：

```go
s, err := c.GenericConfig.New("kube-apiserver", delegationTarget)
...
m := &Master{
	GenericAPIServer:          s,
	ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,
}

// Master contains state for a Kubernetes cluster master/api server.
type Master struct {
	GenericAPIServer *genericapiserver.GenericAPIServer

	ClusterAuthenticationInfo clusterauthenticationtrust.ClusterAuthenticationInfo
}
```

所以Master是对GenericAPIServer的封装。
Master也是从Config中来，这个 Config 定义：

```go
// Config defines configuration for the master
type Config struct {
	GenericConfig *genericapiserver.Config
	ExtraConfig   ExtraConfig
}
```

可以看出，Master的Config包含GenericConfig、ExtraConfig。
Master 的 Config 通过 Complete()。在生成Master的同时，系统会调用InstallLegacyAPI()及InstallAPIs()来安装各种API

kube-apiserver是如何启动Master的：

```go
prepared := s.GenericAPIServer.PrepareRun()
preparedAPIAggregator{APIAggregator: s, runnable: prepared}
prepared.Run(stopCh)

func (s preparedAPIAggregator) Run(stopCh <-chan struct{}) error {
	return s.runnable.Run(stopCh)
}


```

####  Install API

代码路径：

[kubernetes/pkg/master/master.go](https://github.com/kubernetes/kubernetes/blob/master/pkg/master/master.go)

```go
	m := &Master{
		GenericAPIServer:          s,
		ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,
	}

	// install legacy rest storage
	if c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) {
...
		if err := m.InstallLegacyAPI(&c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != nil {
			return nil, err
		}
	}
...
	if err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != nil {
		return nil, err
	}

```

创建 Master 之后调用了InstallLegacyAPI()和InstallAPIs()安装API。





#### Authentication

Authentication 负责对 Kubernetes 中的请求进行认证，只有通过认证的请求才会被执行。在 Kubernetes 中，有BasicAuth, Keystone, X509, Token, ServiceAccount, OIDCIssuer, WebhookToken, AnyToken等认证器。我们来看下 Kubernetes 是如何管理认证器的，及如何对请求进行认证。

调用链：

```go
main() -> app.NewAPIServerCommand() -> Run() -> CreateServerChain() -> CreateKubeAPIServerConfig() -> buildGenericConfig() -> BuildAuthenticator()-> authenticatorConfig.New()
```

代码路径：

[kubernetes/cmd/kube-apiserver/app/server.go](https://github.com/kubernetes/kubernetes/blob/1871f75b32f5d96c62ce6aa8c2d393124b7002aa/cmd/kube-apiserver/app/server.go#L501)

```go
// BuildAuthenticator constructs the authenticator
func BuildAuthenticator(s *options.ServerRunOptions, extclient clientgoclientset.Interface, versionedInformer clientgoinformers.SharedInformerFactory) (authenticator.Request, *spec.SecurityDefinitions, error) {
	authenticatorConfig := s.Authentication.ToAuthenticationConfig()
	if s.Authentication.ServiceAccounts.Lookup || utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) {
		authenticatorConfig.ServiceAccountTokenGetter = serviceaccountcontroller.NewGetterFromClient(
			extclient,
			versionedInformer.Core().V1().Secrets().Lister(),
			versionedInformer.Core().V1().ServiceAccounts().Lister(),
			versionedInformer.Core().V1().Pods().Lister(),
		)
	}
	authenticatorConfig.BootstrapTokenAuthenticator = bootstrap.NewTokenAuthenticator(
		versionedInformer.Core().V1().Secrets().Lister().Secrets(v1.NamespaceSystem),
	)

	return authenticatorConfig.New()
}
```

所以，接下来看authenticator.New()，定义在`kubernetes/pkg/kubeapiserver/authenticator/config.go`中：

```go
// New returns an authenticator.Request or an error that supports the standard
// Kubernetes authentication mechanisms.
func (config Config) New() (authenticator.Request, *spec.SecurityDefinitions, error) {
	var authenticators []authenticator.Request
	var tokenAuthenticators []authenticator.Token
	securityDefinitions := spec.SecurityDefinitions{}

	// front-proxy, BasicAuth methods, local first, then remote
	// Add the front proxy authenticator if requested
	if config.RequestHeaderConfig != nil {
		requestHeaderAuthenticator := headerrequest.NewDynamicVerifyOptionsSecure(
			config.RequestHeaderConfig.CAContentProvider.VerifyOptions,
			config.RequestHeaderConfig.AllowedClientNames,
			config.RequestHeaderConfig.UsernameHeaders,
			config.RequestHeaderConfig.GroupHeaders,
			config.RequestHeaderConfig.ExtraHeaderPrefixes,
		)
		authenticators = append(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, requestHeaderAuthenticator))
	}

	// basic auth
	if len(config.BasicAuthFile) > 0 {
		basicAuth, err := newAuthenticatorFromBasicAuthFile(config.BasicAuthFile)
		if err != nil {
			return nil, nil, err
		}
		authenticators = append(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, basicAuth))

		securityDefinitions["HTTPBasic"] = &spec.SecurityScheme{
			SecuritySchemeProps: spec.SecuritySchemeProps{
				Type:        "basic",
				Description: "HTTP Basic authentication",
			},
		}
	}

	// X509 methods
	if config.ClientCAContentProvider != nil {
		certAuth := x509.NewDynamic(config.ClientCAContentProvider.VerifyOptions, x509.CommonNameUserConversion)
		authenticators = append(authenticators, certAuth)
	}

	// Bearer token methods, local first, then remote
	if len(config.TokenAuthFile) > 0 {
		tokenAuth, err := newAuthenticatorFromTokenFile(config.TokenAuthFile)
		if err != nil {
			return nil, nil, err
		}
		tokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, tokenAuth))
	}
	if len(config.ServiceAccountKeyFiles) > 0 {
		serviceAccountAuth, err := newLegacyServiceAccountAuthenticator(config.ServiceAccountKeyFiles, config.ServiceAccountLookup, config.APIAudiences, config.ServiceAccountTokenGetter)
		if err != nil {
			return nil, nil, err
		}
		tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
	}
	if utilfeature.DefaultFeatureGate.Enabled(features.TokenRequest) && config.ServiceAccountIssuer != "" {
		serviceAccountAuth, err := newServiceAccountAuthenticator(config.ServiceAccountIssuer, config.ServiceAccountKeyFiles, config.APIAudiences, config.ServiceAccountTokenGetter)
		if err != nil {
			return nil, nil, err
		}
		tokenAuthenticators = append(tokenAuthenticators, serviceAccountAuth)
	}
	if config.BootstrapToken {
		if config.BootstrapTokenAuthenticator != nil {
			// TODO: This can sometimes be nil because of
			tokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, config.BootstrapTokenAuthenticator))
		}
	}
	// NOTE(ericchiang): Keep the OpenID Connect after Service Accounts.
	//
	// Because both plugins verify JWTs whichever comes first in the union experiences
	// cache misses for all requests using the other. While the service account plugin
	// simply returns an error, the OpenID Connect plugin may query the provider to
	// update the keys, causing performance hits.
	if len(config.OIDCIssuerURL) > 0 && len(config.OIDCClientID) > 0 {
		oidcAuth, err := newAuthenticatorFromOIDCIssuerURL(oidc.Options{
			IssuerURL:            config.OIDCIssuerURL,
			ClientID:             config.OIDCClientID,
			CAFile:               config.OIDCCAFile,
			UsernameClaim:        config.OIDCUsernameClaim,
			UsernamePrefix:       config.OIDCUsernamePrefix,
			GroupsClaim:          config.OIDCGroupsClaim,
			GroupsPrefix:         config.OIDCGroupsPrefix,
			SupportedSigningAlgs: config.OIDCSigningAlgs,
			RequiredClaims:       config.OIDCRequiredClaims,
		})
		if err != nil {
			return nil, nil, err
		}
		tokenAuthenticators = append(tokenAuthenticators, authenticator.WrapAudienceAgnosticToken(config.APIAudiences, oidcAuth))
	}
	if len(config.WebhookTokenAuthnConfigFile) > 0 {
		webhookTokenAuth, err := newWebhookTokenAuthenticator(config)
		if err != nil {
			return nil, nil, err
		}

		tokenAuthenticators = append(tokenAuthenticators, webhookTokenAuth)
	}

	if len(tokenAuthenticators) > 0 {
		// Union the token authenticators
		tokenAuth := tokenunion.New(tokenAuthenticators...)
		// Optionally cache authentication results
		if config.TokenSuccessCacheTTL > 0 || config.TokenFailureCacheTTL > 0 {
			tokenAuth = tokencache.New(tokenAuth, true, config.TokenSuccessCacheTTL, config.TokenFailureCacheTTL)
		}
		authenticators = append(authenticators, bearertoken.New(tokenAuth), websocket.NewProtocolAuthenticator(tokenAuth))
		securityDefinitions["BearerToken"] = &spec.SecurityScheme{
			SecuritySchemeProps: spec.SecuritySchemeProps{
				Type:        "apiKey",
				Name:        "authorization",
				In:          "header",
				Description: "Bearer Token authentication",
			},
		}
	}

	if len(authenticators) == 0 {
		if config.Anonymous {
			return anonymous.NewAuthenticator(), &securityDefinitions, nil
		}
		return nil, &securityDefinitions, nil
	}

	authenticator := union.New(authenticators...)
    // GroupAdder定义在 /pkg/authentication/group/group_adder.go
    // antenticator调用的是 GroupAdder的 AuthenticateRequest()
	authenticator = group.NewAuthenticatedGroupAdder(authenticator)

	if config.Anonymous {
		// If the authenticator chain returns an error, return an error (don't consider a bad bearer token
		// or invalid username/password combination anonymous).
		authenticator = union.NewFailOnError(authenticator, anonymous.NewAuthenticator())
	}

	return authenticator, &securityDefinitions, nil
}

```



`New()`会根据 kube-apiserver 的参数来生成各个认证器，并把认证器放在 `authenticators` 变量中。比如，如果指定了`–experimental-keystone-url`，则就会生成`keystoneAuthenticator`。这里要强调的是`unionAuthenticator`可以封装多个认证器。

这里还要涉及到一个概念，`GroupAdder`，封装了`authenticator`，定义在[kubernetes/staging/src/k8s.io/apiserver/pkg/authentication/group/authenticated_group_adder.go](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/authentication/group/authenticated_group_adder.go)中：

```go
// AuthenticatedGroupAdder adds system:authenticated group when appropriate
type AuthenticatedGroupAdder struct {
	// Authenticator is delegated to make the authentication decision
	Authenticator authenticator.Request
}

// NewAuthenticatedGroupAdder wraps a request authenticator, and adds the system:authenticated group when appropriate.
// Authentication must succeed, the user must not be system:anonymous, the groups system:authenticated or system:unauthenticated must
// not be present
func NewAuthenticatedGroupAdder(auth authenticator.Request) authenticator.Request {
	return &AuthenticatedGroupAdder{auth}
}

```

所以，kube-apiserver的认证器是 AuthenticatedGroupAdder，AuthenticatedGroupAdder定义有认证的入口：

```go
// 实现AuthenticateRequest()
// 返回user.DefaultInfo
func (g *AuthenticatedGroupAdder) AuthenticateRequest(req *http.Request) (*authenticator.Response, bool, error) {
	r, ok, err := g.Authenticator.AuthenticateRequest(req)
	if err != nil || !ok {
		return nil, ok, err
	}

	if r.User.GetName() == user.Anonymous {
		return r, true, nil
	}
	for _, group := range r.User.GetGroups() {
		if group == user.AllAuthenticated || group == user.AllUnauthenticated {
			return r, true, nil
		}
	}

	r.User = &user.DefaultInfo{
		Name:   r.User.GetName(),
		UID:    r.User.GetUID(),
		Groups: append(r.User.GetGroups(), user.AllAuthenticated),
		Extra:  r.User.GetExtra(),
	}
	return r, true, nil
}

```

AuthenticatedGroupAdder 的 `AuthenticateRequest()` 会调用 unionAuthenticator 的`AuthenticateRequest()`对请求进行认证，得到 user 信息之后返回。

关于 Group，定义在`kubernetes/staging/src/k8s.io/apiserver/pkg/authentication/user/user.go`中，`authenticator.New()`传入的是AllAuthenticated。

我们分析一个基本认证

```go
	// basic auth
	if len(config.BasicAuthFile) > 0 {
		basicAuth, err := newAuthenticatorFromBasicAuthFile(config.BasicAuthFile)
		if err != nil {
			return nil, nil, err
		}
		authenticators = append(authenticators, authenticator.WrapAudienceAgnosticRequest(config.APIAudiences, basicAuth))

		securityDefinitions["HTTPBasic"] = &spec.SecurityScheme{
			SecuritySchemeProps: spec.SecuritySchemeProps{
				Type:        "basic",
				Description: "HTTP Basic authentication",
			},
		}
	}

.....
// newAuthenticatorFromBasicAuthFile returns an authenticator.Request or an error
func newAuthenticatorFromBasicAuthFile(basicAuthFile string) (authenticator.Request, error) {
	basicAuthenticator, err := passwordfile.NewCSV(basicAuthFile)
	if err != nil {
		return nil, err
	}

	return basicauth.New(basicAuthenticator), nil
}

...
func (a *Authenticator) AuthenticateRequest(req *http.Request) (*authenticator.Response, bool, error) {
	username, password, found := req.BasicAuth()
	if !found {
		return nil, false, nil
	}

	resp, ok, err := a.auth.AuthenticatePassword(req.Context(), username, password)

	// If the password authenticator didn't error, provide a default error
	if !ok && err == nil {
		err = errInvalidAuth
	}

	return resp, ok, err
}

```

该方法会从请求中获取用户名和密码，然后调用所封装的认证器的AuthenticatePassword()方法进行认证。



**unionAuthenticator**

unionAuthenticator定义在[/kubernetes/staging/src/k8s.io/apiserver/pkg/authentication/request/union/union.go](https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/pkg/authentication/request/union/union.go):

```go
// unionAuthRequestHandler authenticates requests using a chain of authenticator.Requests
type unionAuthRequestHandler struct {
	// Handlers is a chain of request authenticators to delegate to
	Handlers []authenticator.Request
	// FailOnError determines whether an error returns short-circuits the chain
	FailOnError bool
}

// New returns a request authenticator that validates credentials using a chain of authenticator.Request objects.
// The entire chain is tried until one succeeds. If all fail, an aggregate error is returned.
func New(authRequestHandlers ...authenticator.Request) authenticator.Request {
	if len(authRequestHandlers) == 1 {
		return authRequestHandlers[0]
	}
	return &unionAuthRequestHandler{Handlers: authRequestHandlers, FailOnError: false}
}
```

unionAuthenticator 的 `AuthenticateRequest()` 方法定义如下：

```go
// 逐个调用 authRequestHandler，如果有一个成功，则返回
func (authHandler *unionAuthRequestHandler) AuthenticateRequest(req *http.Request) (*authenticator.Response, bool, error) {
	var errlist []error
	for _, currAuthRequestHandler := range authHandler.Handlers {
		resp, ok, err := currAuthRequestHandler.AuthenticateRequest(req)
		if err != nil {
			if authHandler.FailOnError {
				return resp, ok, err
			}
			errlist = append(errlist, err)
			continue
		}

		if ok {
			return resp, ok, err
		}
	}

	return nil, false, utilerrors.NewAggregate(errlist)
}

```

`AuthenticateRequest()`会轮询每一个 authenticator，如果有一个 authenticator 认证成功，则直接返回认证成功。

**对请求进行认证**

调用链：

```
main() -> app.NewAPIServerCommand() -> Run() -> CreateServerChain() -> CreateKubeAPIServerConfig() -> buildGenericConfig() -> genericapiserver.NewConfig(legacyscheme.Codecs)-> DefaultBuildHandlerChain()
```

代码路径：

[staging/src/k8s.io/apiserver/pkg/server/config.go](https://github.com/kubernetes/kubernetes/blob/323f34858de18b862d43c40b2cced65ad8e24052/staging/src/k8s.io/apiserver/pkg/server/config.go)

```go
func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler {
	handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)
	if c.FlowControl != nil {
		handler = genericfilters.WithPriorityAndFairness(handler, c.LongRunningFunc, c.FlowControl)
	} else {
		handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)
	}
	handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)
	handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)
	failedHandler := genericapifilters.Unauthorized(c.Serializer, c.Authentication.SupportsBasicAuth)
	failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)
	handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)
	handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, nil, nil, nil, "true")
	handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)
	handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)
	handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)
	if c.SecureServing != nil && !c.SecureServing.DisableHTTP2 && c.GoawayChance > 0 {
		handler = genericfilters.WithProbabilisticGoaway(handler, c.GoawayChance)
	}
	handler = genericfilters.WithPanicRecovery(handler)
	return handler
}
```

我们注意到 `handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)`

代码路径：[kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authentication.go](https://github.com/kubernetes/kubernetes/blob/323f34858de18b862d43c40b2cced65ad8e24052/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authentication.go)

```go
func WithAuthentication(handler http.Handler, auth authenticator.Request, failed http.Handler, apiAuds authenticator.Audiences) http.Handler {
	if auth == nil {
		klog.Warningf("Authentication is disabled")
		return handler
	}
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		authenticationStart := time.Now()

		if len(apiAuds) > 0 {
			req = req.WithContext(authenticator.WithAudiences(req.Context(), apiAuds))
		}
		//  handler中的认证
		resp, ok, err := auth.AuthenticateRequest(req)
		defer recordAuthMetrics(resp, ok, err, apiAuds, authenticationStart)
		if err != nil || !ok {
			if err != nil {
				klog.Errorf("Unable to authenticate the request due to an error: %v", err)
			}
			failed.ServeHTTP(w, req)
			return
		}

		if !audiencesAreAcceptable(apiAuds, resp.Audiences) {
			err = fmt.Errorf("unable to match the audience: %v , accepted: %v", resp.Audiences, apiAuds)
			klog.Error(err)
			failed.ServeHTTP(w, req)
			return
		}

		// authorization header is not required anymore in case of a successful authentication.
		req.Header.Del("Authorization")

		req = req.WithContext(genericapirequest.WithUser(req.Context(), resp.User))
		handler.ServeHTTP(w, req)
	})
}
```

其中，http.HandlerFunc 本身就是一个handler。所以`WithAuthentication()`先调用`auth.AuthenticateRequest()`对请求进行验证，然后调用前handler的`ServeHTTP()`对请求接着作处理，以达到在处理前进行认证的目的。





#### Authorization

Authorization 负责 Kubernetes 中对请求进行授权，只有通过授权的请求才会被执行。在Kubernetes中，主要有ABAC(Attributes Based Access Control)，RBAC(Role Based Access Contro)，AlwaysAllow，AlwaysDeny和Webhook(调用网络接口进行授权)这几种授权器。我们来看下 Kubernetes 是如何管理授权器的，及如何对请求进行授权。

调用链：

```go
main() -> app.NewAPIServerCommand() -> Run() -> CreateServerChain() -> CreateKubeAPIServerConfig() -> buildGenericConfig() -> BuildAuthorizer()-> authorizationConfig.New()
```

代码路径：

[kubernetes/pkg/kubeapiserver/authorizer/config.go ](https://github.com/kubernetes/kubernetes/blob/323f34858de18b862d43c40b2cced65ad8e24052/pkg/kubeapiserver/authorizer/config.go)

```go
// New returns the right sort of union of multiple authorizer.Authorizer objects
// based on the authorizationMode or an error.
func (config Config) New() (authorizer.Authorizer, authorizer.RuleResolver, error) {
	if len(config.AuthorizationModes) == 0 {
		return nil, nil, fmt.Errorf("at least one authorization mode must be passed")
	}

	var (
		authorizers   []authorizer.Authorizer
		ruleResolvers []authorizer.RuleResolver
	)

	for _, authorizationMode := range config.AuthorizationModes {
		// Keep cases in sync with constant list in k8s.io/kubernetes/pkg/kubeapiserver/authorizer/modes/modes.go.
		switch authorizationMode {
		case modes.ModeNode:
			graph := node.NewGraph()
			node.AddGraphEventHandlers(
				graph,
				config.VersionedInformerFactory.Core().V1().Nodes(),
				config.VersionedInformerFactory.Core().V1().Pods(),
				config.VersionedInformerFactory.Core().V1().PersistentVolumes(),
				config.VersionedInformerFactory.Storage().V1().VolumeAttachments(),
			)
			nodeAuthorizer := node.NewAuthorizer(graph, nodeidentifier.NewDefaultNodeIdentifier(), bootstrappolicy.NodeRules())
			authorizers = append(authorizers, nodeAuthorizer)

		case modes.ModeAlwaysAllow:
			alwaysAllowAuthorizer := authorizerfactory.NewAlwaysAllowAuthorizer()
			authorizers = append(authorizers, alwaysAllowAuthorizer)
			ruleResolvers = append(ruleResolvers, alwaysAllowAuthorizer)
		case modes.ModeAlwaysDeny:
			alwaysDenyAuthorizer := authorizerfactory.NewAlwaysDenyAuthorizer()
			authorizers = append(authorizers, alwaysDenyAuthorizer)
			ruleResolvers = append(ruleResolvers, alwaysDenyAuthorizer)
		case modes.ModeABAC:
			abacAuthorizer, err := abac.NewFromFile(config.PolicyFile)
			if err != nil {
				return nil, nil, err
			}
			authorizers = append(authorizers, abacAuthorizer)
			ruleResolvers = append(ruleResolvers, abacAuthorizer)
		case modes.ModeWebhook:
			webhookAuthorizer, err := webhook.New(config.WebhookConfigFile,
				config.WebhookVersion,
				config.WebhookCacheAuthorizedTTL,
				config.WebhookCacheUnauthorizedTTL,
				config.CustomDial)
			if err != nil {
				return nil, nil, err
			}
			authorizers = append(authorizers, webhookAuthorizer)
			ruleResolvers = append(ruleResolvers, webhookAuthorizer)
		case modes.ModeRBAC:
			rbacAuthorizer := rbac.New(
				&rbac.RoleGetter{Lister: config.VersionedInformerFactory.Rbac().V1().Roles().Lister()},
				&rbac.RoleBindingLister{Lister: config.VersionedInformerFactory.Rbac().V1().RoleBindings().Lister()},
				&rbac.ClusterRoleGetter{Lister: config.VersionedInformerFactory.Rbac().V1().ClusterRoles().Lister()},
				&rbac.ClusterRoleBindingLister{Lister: config.VersionedInformerFactory.Rbac().V1().ClusterRoleBindings().Lister()},
			)
			authorizers = append(authorizers, rbacAuthorizer)
			ruleResolvers = append(ruleResolvers, rbacAuthorizer)
		default:
			return nil, nil, fmt.Errorf("unknown authorization mode %s specified", authorizationMode)
		}
	}

	return union.New(authorizers...), union.NewRuleResolvers(ruleResolvers...), nil
}

```

在 kube-apiserver 的参数中，有`–authorization-mode`参数，授权器就是根据`–authorization-mode`参数中指定的内容来生成的。

New() 会依据 authorizationModes 生成相应的 authorizer，并把多个 authorizers 打包成 unionAuthorizer 返回。最后 server.go 中生成的 apiAuthorizer 会赋值给 genericConfig.Authorizer 以生成 master。

代码路径：

[kubernetes/cmd/kube-apiserver/app/server.go](https://github.com/kubernetes/kubernetes/blob/ca324214be0c3823b309a145b876bbb79ccd742a/cmd/kube-apiserver/app/server.go)

```go
genericConfig.Authorization.Authorizer, genericConfig.RuleResolver, err = BuildAuthorizer(s, genericConfig.EgressSelector, versionedInformers)
```



**unionAuthorizer**

代码路径：[kubernetes/staging/src/k8s.io/apiserver/pkg/authorization/union/union.go](https://github.com/kubernetes/kubernetes/blob/327f53ba57aeaa4b7e7c20b1ef98c42b26b7ea7f/staging/src/k8s.io/apiserver/pkg/authorization/union/union.go)

```go
// unionAuthzHandler authorizer against a chain of authorizer.Authorizer
type unionAuthzHandler []authorizer.Authorizer

// New returns an authorizer that authorizes against a chain of authorizer.Authorizer objects
func New(authorizationHandlers ...authorizer.Authorizer) authorizer.Authorizer {
	return unionAuthzHandler(authorizationHandlers)
}

// Authorizes against a chain of authorizer.Authorizer objects and returns nil if successful and returns error if unsuccessful
func (authzHandler unionAuthzHandler) Authorize(ctx context.Context, a authorizer.Attributes) (authorizer.Decision, string, error) {
	var (
		errlist    []error
		reasonlist []string
	)

	for _, currAuthzHandler := range authzHandler {
		decision, reason, err := currAuthzHandler.Authorize(ctx, a)

		if err != nil {
			errlist = append(errlist, err)
		}
		if len(reason) != 0 {
			reasonlist = append(reasonlist, reason)
		}
		switch decision {
		case authorizer.DecisionAllow, authorizer.DecisionDeny:
			return decision, reason, err
		case authorizer.DecisionNoOpinion:
			// continue to the next authorizer
		}
	}

	return authorizer.DecisionNoOpinion, strings.Join(reasonlist, "\n"), utilerrors.NewAggregate(errlist)
}


```

unionAuthorizer 本身是一个 Authorizer 列表，其Authorize() 方法会调用列表中每一个 Authorizer 的Authorize() 方法，一旦有一个 Authorizer 授权通过，则 unionAuthorizer 的授权通过。



##### **ABAC授权器**

ABAC是基于属性的访问控制，目前ABAC支持apiVersion, kind, spec, namespace, resource等属性。ABAC规则需要保存在文件中：

```json
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"group":"system:authenticated",  "nonResourcePath": "*", "readonly": true}}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"group":"system:unauthenticated", "nonResourcePath": "*", "readonly": true}}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"admin",     "namespace": "*",              "resource": "*",         "apiGroup": "*"                   }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"scheduler", "namespace": "*",              "resource": "pods",                       "readonly": true }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"scheduler", "namespace": "*",              "resource": "bindings"                                     }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"kubelet",   "namespace": "*",              "resource": "pods",                       "readonly": true }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"kubelet",   "namespace": "*",              "resource": "services",                   "readonly": true }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"kubelet",   "namespace": "*",              "resource": "endpoints",                  "readonly": true }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"kubelet",   "namespace": "*",              "resource": "events"                                       }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"alice",     "namespace": "projectCaribou", "resource": "*",         "apiGroup": "*"                   }}
{"apiVersion": "abac.authorization.kubernetes.io/v1beta1", "kind": "Policy", "spec": {"user":"bob",       "namespace": "projectCaribou", "resource": "*",         "apiGroup": "*", "readonly": true }}
```

ABAC授权器定义在`kubernetes/pkg/auth/authorizer/abac/abac.go`中：

```go
type PolicyList []*abac.Policy

// 从policy文件构建plicylist
func NewFromFile(path string) (PolicyList, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	pl := make(PolicyList, 0)

	decoder := abac.Codecs.UniversalDecoder()

	i := 0
	unversionedLines := 0
	for scanner.Scan() {
		i++
		p := &abac.Policy{}
		b := scanner.Bytes()

		// skip comment lines and blank lines
		trimmed := strings.TrimSpace(string(b))
		if len(trimmed) == 0 || strings.HasPrefix(trimmed, "#") {
			continue
		}

		decodedObj, _, err := decoder.Decode(b, nil, nil)
		if err != nil {
			if !(runtime.IsMissingVersion(err) || runtime.IsMissingKind(err) || runtime.IsNotRegisteredError(err)) {
				return nil, policyLoadError{path, i, b, err}
			}
			unversionedLines++
			// Migrate unversioned policy object
			oldPolicy := &v0.Policy{}
			if err := runtime.DecodeInto(decoder, b, oldPolicy); err != nil {
				return nil, policyLoadError{path, i, b, err}
			}
			if err := abac.Scheme.Convert(oldPolicy, p, nil); err != nil {
				return nil, policyLoadError{path, i, b, err}
			}
			pl = append(pl, p)
			continue
		}

		decodedPolicy, ok := decodedObj.(*abac.Policy)
		if !ok {
			return nil, policyLoadError{path, i, b, fmt.Errorf("unrecognized object: %#v", decodedObj)}
		}
		pl = append(pl, decodedPolicy)
	}

	if unversionedLines > 0 {
		klog.Warningf("Policy file %s contained unversioned rules. See docs/admin/authorization.md#abac-mode for ABAC file format details.", path)
	}

	if err := scanner.Err(); err != nil {
		return nil, policyLoadError{path, -1, nil, err}
	}
	return pl, nil
}

```

`NewFromFile()`读取 ABAC policy 文件，然后构建 policyList，并返回。
policyList 类型实现了`Authorize()`方法:

```go
// Authorize implements authorizer.Authorize
func (pl PolicyList) Authorize(ctx context.Context, a authorizer.Attributes) (authorizer.Decision, string, error) {
	for _, p := range pl {
		if matches(*p, a) {
			return authorizer.DecisionAllow, "", nil
		}
	}
	return authorizer.DecisionNoOpinion, "No policy matched.", nil
	// TODO: Benchmark how much time policy matching takes with a medium size
	// policy file, compared to other steps such as encoding/decoding.
	// Then, add Caching only if needed.
}
```

`Authorize()`方法会使用 policyList 中每一条 policy 去匹配请求。如果匹配到，则直接通过；否则不通过。

再来看下匹配函数`matches()`：

```go
func matches(p abac.Policy, a authorizer.Attributes) bool {
	if subjectMatches(p, a.GetUser()) {
		if verbMatches(p, a) {
			// Resource and non-resource requests are mutually exclusive, at most one will match a policy
			if resourceMatches(p, a) {
				return true
			}
			if nonResourceMatches(p, a) {
				return true
			}
		}
	}
	return false
}
```

`matches()`会执行`subjectMatches()`，`verbMatches()`及`resourceMatches()`或`nonResourceMatches()`。

##### RBAC授权器

RBAC是指基于角色的访问控制。可以把用户和角色相关联，从而获取用户拥有的权限。首先来看下角色，在Kubernetes中，有两种类型的角色，一种是namespaced的角色；另一种是全局的角色。
namespaced 的角色Yaml文件如下：

```yaml
kind: Role
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  namespace: default
  name: pod-reader
rules:
- apiGroups: [""] # "" indicates the core API group
  resources: ["pods"]
  verbs: ["get", "watch", "list"]
```

全局的角色Yaml文件如下：

```yaml
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  # "namespace" omitted since ClusterRoles are not namespaced
  name: secret-reader
rules:
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "watch", "list"]
```

一个角色对应着多条的规则。

当然，还需要一种机制关联角色和用户。这就是RoleBinding和ClusterRoleBinding。例子(表示把User jane绑定到Role pod-reader上)如下：

```yaml
# This role binding allows "jane" to read pods in the "default" namespace.
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1beta1
metadata:
  name: read-pods
  namespace: default
subjects:
- kind: User
  name: jane
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod-reader
  apiGroup: rbac.authorization.k8s.io
```

具体RBAC的功能可以参照官方文档。

RBAC授权器定义在[kubernetes/plugin/pkg/auth/authorizer/rbac/rbac.go ](https://github.com/kubernetes/kubernetes/blob/323f34858de18b862d43c40b2cced65ad8e24052/plugin/pkg/auth/authorizer/rbac/rbac.go)中：

```go
type RBACAuthorizer struct {
	authorizationRuleResolver RequestToRuleMapper
}

func New(...) *RBACAuthorizer {
	authorizer := &RBACAuthorizer{
		authorizationRuleResolver: rbacregistryvalidation.NewDefaultRuleResolver(
			roles, roleBindings, clusterRoles, clusterRoleBindings,
		),
	}
	return authorizer
}
```

RBAC授权方法如下:

```go
func (r *RBACAuthorizer) Authorize(ctx context.Context, requestAttributes authorizer.Attributes) (authorizer.Decision, string, error) {
	ruleCheckingVisitor := &authorizingVisitor{requestAttributes: requestAttributes}

	r.authorizationRuleResolver.VisitRulesFor(requestAttributes.GetUser(), requestAttributes.GetNamespace(), ruleCheckingVisitor.visit)
	if ruleCheckingVisitor.allowed {
		return authorizer.DecisionAllow, ruleCheckingVisitor.reason, nil
	}

...
	return authorizer.DecisionNoOpinion, reason, nil
}

func (v *authorizingVisitor) visit(source fmt.Stringer, rule *rbacv1.PolicyRule, err error) bool {
	if rule != nil && RuleAllows(v.requestAttributes, rule) {
		v.allowed = true
		v.reason = fmt.Sprintf("RBAC: allowed by %s", source.String())
		return false
	}
	if err != nil {
		v.errors = append(v.errors, err)
	}
	return true
}
```

使用VisitRulesFor()获取用户的规则，再调用RulesAllow()来授权。
RulesAllow()定义如下：

```go
func RuleAllows(requestAttributes authorizer.Attributes, rule *rbacv1.PolicyRule) bool {
	if requestAttributes.IsResourceRequest() {
		combinedResource := requestAttributes.GetResource()
		if len(requestAttributes.GetSubresource()) > 0 {
			combinedResource = requestAttributes.GetResource() + "/" + requestAttributes.GetSubresource()
		}

		return rbacv1helpers.VerbMatches(rule, requestAttributes.GetVerb()) &&
			rbacv1helpers.APIGroupMatches(rule, requestAttributes.GetAPIGroup()) &&
			rbacv1helpers.ResourceMatches(rule, combinedResource, requestAttributes.GetSubresource()) &&
			rbacv1helpers.ResourceNameMatches(rule, requestAttributes.GetName())
	}

	return rbacv1helpers.VerbMatches(rule, requestAttributes.GetVerb()) &&
		rbacv1helpers.NonResourceURLMatches(rule, requestAttributes.GetPath())
}
```

RuleAllows()通过调用`VerbMatches()`, `APIGroupMatches()`, `ResourceMatches()`, `ResourceNameMatches()`等函数进行规则匹配

**对请求进行认证**

调用链：

```
main() -> app.NewAPIServerCommand() -> Run() -> CreateServerChain() -> CreateKubeAPIServerConfig() -> buildGenericConfig() -> genericapiserver.NewConfig(legacyscheme.Codecs)-> DefaultBuildHandlerChain()
```

代码路径：

[staging/src/k8s.io/apiserver/pkg/server/config.go](https://github.com/kubernetes/kubernetes/blob/ca324214be0c3823b309a145b876bbb79ccd742a/staging/src/k8s.io/apiserver/pkg/server/config.go)

```go
func DefaultBuildHandlerChain(apiHandler http.Handler, c *Config) http.Handler {
	handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)
	if c.FlowControl != nil {
		handler = genericfilters.WithPriorityAndFairness(handler, c.LongRunningFunc, c.FlowControl)
	} else {
		handler = genericfilters.WithMaxInFlightLimit(handler, c.MaxRequestsInFlight, c.MaxMutatingRequestsInFlight, c.LongRunningFunc)
	}
	handler = genericapifilters.WithImpersonation(handler, c.Authorization.Authorizer, c.Serializer)
	handler = genericapifilters.WithAudit(handler, c.AuditBackend, c.AuditPolicyChecker, c.LongRunningFunc)
	failedHandler := genericapifilters.Unauthorized(c.Serializer, c.Authentication.SupportsBasicAuth)
	failedHandler = genericapifilters.WithFailedAuthenticationAudit(failedHandler, c.AuditBackend, c.AuditPolicyChecker)
	handler = genericapifilters.WithAuthentication(handler, c.Authentication.Authenticator, failedHandler, c.Authentication.APIAudiences)
	handler = genericfilters.WithCORS(handler, c.CorsAllowedOriginList, nil, nil, nil, "true")
	handler = genericfilters.WithTimeoutForNonLongRunningRequests(handler, c.LongRunningFunc, c.RequestTimeout)
	handler = genericfilters.WithWaitGroup(handler, c.LongRunningFunc, c.HandlerChainWaitGroup)
	handler = genericapifilters.WithRequestInfo(handler, c.RequestInfoResolver)
	if c.SecureServing != nil && !c.SecureServing.DisableHTTP2 && c.GoawayChance > 0 {
		handler = genericfilters.WithProbabilisticGoaway(handler, c.GoawayChance)
	}
	handler = genericfilters.WithPanicRecovery(handler)
	return handler
}
```

注意到： `handler := genericapifilters.WithAuthorization(apiHandler, c.Authorization.Authorizer, c.Serializer)`

代码路径：[kubernetes/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go ](https://github.com/kubernetes/kubernetes/blob/ca324214be0c3823b309a145b876bbb79ccd742a/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go)

```go
func WithAuthorization(handler http.Handler, a authorizer.Authorizer, s runtime.NegotiatedSerializer) http.Handler {
	if a == nil {
		klog.Warningf("Authorization is disabled")
		return handler
	}
	return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
		ctx := req.Context()
		ae := request.AuditEventFrom(ctx)

		attributes, err := GetAuthorizerAttributes(ctx)
		if err != nil {
			responsewriters.InternalError(w, req, err)
			return
		}
		authorized, reason, err := a.Authorize(ctx, attributes)
		// an authorizer like RBAC could encounter evaluation errors and still allow the request, so authorizer decision is checked before error here.
		if authorized == authorizer.DecisionAllow {
			audit.LogAnnotation(ae, decisionAnnotationKey, decisionAllow)
			audit.LogAnnotation(ae, reasonAnnotationKey, reason)
			handler.ServeHTTP(w, req)
			return
		}
		if err != nil {
			audit.LogAnnotation(ae, reasonAnnotationKey, reasonError)
			responsewriters.InternalError(w, req, err)
			return
		}

		klog.V(4).Infof("Forbidden: %#v, Reason: %q", req.RequestURI, reason)
		audit.LogAnnotation(ae, decisionAnnotationKey, decisionForbid)
		audit.LogAnnotation(ae, reasonAnnotationKey, reason)
		responsewriters.Forbidden(ctx, attributes, w, req, reason, s)
	})
}

```

接下来的过程和认证器一样

#### Admission

在进行用户认证和权限授予后，apiserver就会查询/修改etcd存储，以完成请求。

 Admission Controller（准入控制）是 Kubernetes API Server 用于拦截请求的一种手段。Admission可以做到对请求的资源对象进行校验，修改。

![](../Kubernetes 网络入门/img/2019070310251413.png)

- MutatingAdmissionWebhook：在对象持久化之前进行修改
- ValidatingAdmissionWebhook：在对象持久化之前进行

**Admission Controller 工作流程**

+ API Server 接收到客户端请求后首先进行认证鉴权，认证鉴权后才会进行 endpoint handler 处理
+ 当API Server 接收到对象后根据 http 的路径可以得到版本号，然后将 body 反序列化成 versioned object
+ versioned object 转化为 internal object，即没有版本的内部类型，这种资源类型是所有 versioned 类型的超集。只有转化为 internal 后才能适配所有的客户端 versioned object 的校验、
+ Admission Controller 具体的 admit 操作，可以通过这里修改资源对象，例如为 Pod 挂载一个默认的 Service Account 等
+ API Server internal object validation，校验某个资源对象数据和格式是否合法，例如：Service Name 的字符个数不能超过63等
+ Admission Controller validate，可以自定义任何的对象校验规则
+ internal object 转化为 versioned object，并且持久化存储到 etcd


Kubernetes 1.10之前的版本，`--admission-control` 打开 Admission Controller。同时`--admission-control `的顺序决定 Admission 运行的先后

Kubernetes 1.10之后的版本，`--admission-control` 已经废弃，建议使用 `--enable-admission-plugins --disable-admission-plugins` 指定需要打开或者关闭的 Admission Controller。 同时用户指定的顺序并不影响实际 Admission Controllers 的执行顺序

```
 --enable-admission-plugins=NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,Priority,ResourceQuota,PodSecurityPolicy   
```

Webhook Admission 属于同步调用，需要部署自己的 webhook server，创建自定义的配置资源对象： ValidatingWebhookConfiguration 或 MutatingWebhookConfiguration

```
[root@master ~]# kubectl api-resources | grep webhook
mutatingwebhookconfigurations                  admissionregistration.k8s.io   false        MutatingWebhookConfiguration
validatingwebhookconfigurations                admissionregistration.k8s.io   false        ValidatingWebhookConfiguration


[root@master ~]# kubectl api-versions | grep admissionregistration.k8s.io/v1beta1
admissionregistration.k8s.io/v1beta1
```

 **部署** 

 定义 ValidatingWebhookConfiguration 或者 MutatingWebhookConfiguration

```
apiVersion: admissionregistration.k8s.io/v1beta1
kind: MutatingWebhookConfiguration
metadata:
  name: <name>
  labels:
    app: <label>
webhooks:
  - name: <webhook name, e.g., pod-policy.example.io>  逗号分割，限制必须三段
    clientConfig:
      service:
        namespace: <namespace of the front-end service>
        name: <name of the front-end service>
      caBundle: <pem encoded ca cert that signs the server cert used by the webhook>
    rules:
      - operations: [ "CREATE" ]
        apiGroups: [""]
        apiVersions: ["v1"]
        resources: ["pods"]
    namespaceSelector:
      matchLabels:
        <key>: <value>

```

**创建自己的 webhook 程序流程**

+ 创建TLS Certificate，即证书
+ 编写服务端代码，服务端代码需要使用证书
+ 根据证书创建k8s sercret
+ 创建k8s Deployment和Service
+ 创建k8s WebhookConfiguration，其中需要使用之前创建的证书

**准入控制器列表**

准入控制器是写入apiserver源码的，无法动态添加。可以通过`kube-apiserver -h | grep enable-admission-plugins`查看支持的准入控制器，也可以在github上查看准入控制器列表以及实现细节：https://github.com/kubernetes/kubernetes/tree/master/plugin/pkg/admission。

以下是目前支持的准入控制器：

- AlwaysAdmit：全部允许，相当于没有准入控制器。
- AlwaysPull/images/2020：强制修改每一个新Pod强制拉取镜像。
- AlwaysDeny：拒绝所有请求。
- DefaultStorageClass：如果PersistentVolumeClaim没有指定StorageClass，则为其添加一个默认的StorageClass。
- DefaultTolerationSeconds：如果Pod没有设置toleration，则默认设置对`notready:NoExecute`和`unreachable:NoExecute`的toleration为5分钟。
- DenyExecOnPrivileged：拦截所有特权级容器运行的命令。该准入控制器已合并至`DenyEscalatingExec`，并将在1.18版本移除。
- DenyEscalatingExec：阻止容器运行提权类命令，包括特权级容器，或者说有着host的IPC命名空间或PID命名空间。
- EventRateLimit：控制apiserver接收事件请求的速率，以缓解负载过大的问题。
- ExtendedResourceToleration：用于有扩展类资源的专用节点，比如说GPU，FPGA。如果请求需要扩展资源，则自动为其添加toleration以帮助选择节点。
- ImagePolicyWebhook：允许后端的webhook判断镜像拉取策略，例如配置镜像仓库的密钥。
- LimitPodHardAntiAffinityTopology：拒绝所有在`requiredDuringSchedulingRequiredDuringExecution`中定义除`kubernetes.io/hostname`之外的拓扑关键字的Pod。
- LimitRanger：确保所有资源请求不会超过 namespace 的 LimitRange。
- MutatingAdmissionWebhook：调用与请求匹配的任何变更 webhook。
- NamespaceAutoProvision：检查请求引用的命名空间，如果不存在则自动创建命名空间。
- NamespaceExists：检查请求引用的命名空间，如果不存在则拒绝。
- NamespaceLifecycle：保证正在终止的命名空间无法创建对象；拒绝引用了不存在的命名空间的请求；保证无法删除默认的三个命名空间：`default`，`kube-system`，`kube-public`。
- NodeRestriction：限制了kubelet可以修改的Node和Pod对象，往往与权限授予的Node模式配合使用。
- OwnerReferencesPermissionEnforcement：保护对`metadata.ownerReferences`对象的访问，以便只有对该对象具有“删除”权限的用户才能对其进行更改。
- PersistentVolumeLabel：如果是云服务商定义的PV，则自动为其添加上region和zone的标签。已弃用，使用`cloud-controller-manager`代替。
- PodNodeSelector：通过读取命名空间注释和全局配置来限制可在命名空间内使用的节点选择器。
- PersistentVolumeClaimResize：验证更改PVC大小的请求。
- PodPreset：允许在Pod启动时注入一些信息，比如环境变量，secret，volume等等，需要和podpreset资源对象配合使用。
- PodSecurityPolicy：在创建和修改Pod时，根据请求的安全上下文和可用的Pod安全策略确定是否应该允许它。
- PodTolerationRestriction：验证容器的容忍度与其命名空间的容忍度之间是否存在冲突，并在存在冲突时拒绝该容器请求。
- Priority：使用priorityClassName字段并填充优先级的整数值。如果未找到优先级，则拒绝Pod。
- ResourceQuota：确保请求不违反namespace中的resourcequota对象。
- SecurityContextDeny：拒绝任何试图设置某些升级的SecurityContext字段的pod。
- ServiceAccount：自动化ServiceAccount设置，包括为Pod填充serviceaccount字段，以及挂载secret。
- StorageObjectInUseProtection：为新创建的PVC添加`kubernetes.io/pvc-protection`和`kubernetes.io/pv-protection`字段，防止用户在使用PV或PVC时删除它们。
- ValidatingAdmissionWebhook：调用与请求匹配的任何验证webhook。如果任何一个webhook拒绝请求，则请求失败。

以上是目前apiserver可以使用的准入控制器，更详细的内容请参考官网：https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do。

如果以上准入控制器无法满足需要，可以自己实现准入控制器，然后编译进kube-apiserver程序中。

**小结**

- 准入控制器是请求持久化至etcd之前的拦截器，可以修改/拦截请求。
- 可以在apiserver启动时传入允许/拒绝的准入控制器。
- apiserver提供了一系列内置的准入控制器，如无法满足需求也可自己实现。



##### 注册插件

**调用链**

```
app.NewAPIServerCommand() -> options.NewServerRunOptions() -> kubeoptions.NewAdmissionOptions() -> genericoptions.NewAdmissionOptions() ->
RegisterAllAdmissionPlugins(options.Plugins)
```

注册

```go
func RegisterAllAdmissionPlugins(plugins *admission.Plugins) {
	admit.Register(plugins) // DEPRECATED as no real meaning
	alwayspull/images/2020.Register(plugins)
	antiaffinity.Register(plugins)
	defaulttolerationseconds.Register(plugins)
	defaultingressclass.Register(plugins)
	deny.Register(plugins) // DEPRECATED as no real meaning
	eventratelimit.Register(plugins)
	exec.Register(plugins)
	extendedresourcetoleration.Register(plugins)
	gc.Register(plugins)
	imagepolicy.Register(plugins)
	limitranger.Register(plugins)
	autoprovision.Register(plugins)
	exists.Register(plugins)
	noderestriction.Register(plugins)
	nodetaint.Register(plugins)
	label.Register(plugins) // DEPRECATED, future PVs should not rely on labels for zone topology
	podnodeselector.Register(plugins)
	podpreset.Register(plugins)
	podtolerationrestriction.Register(plugins)
	runtimeclass.Register(plugins)
	resourcequota.Register(plugins)
	podsecuritypolicy.Register(plugins)
	podpriority.Register(plugins)
	scdeny.Register(plugins)
	serviceaccount.Register(plugins)
	setdefault.Register(plugins)
	resize.Register(plugins)
	storageobjectinuseprotection.Register(plugins)
	certapproval.Register(plugins)
	certsigning.Register(plugins)
	certsubjectrestriction.Register(plugins)
}
```

##### 初始化插件

调用链：

```
main() -> app.NewAPIServerCommand() -> Run() -> CreateServerChain() -> CreateKubeAPIServerConfig() -> buildGenericConfig() -> s.Admission.ApplyTo() ->
a.GenericAdmission.ApplyTo() -> a.Plugins.NewFromPlugins()->ps.InitPlugin()
```

**buildGenericConfig**

Config 结构主要用来初始化 admission 插件，路径实现 `pkg/kubeapiserver/admission/config.go`

```go
admissionConfig := &kubeapiserveradmission.Config{
	ExternalInformers:    versionedInformers,
	LoopbackClientConfig: genericConfig.LoopbackClientConfig,
	CloudConfigFile:      s.CloudProvider.CloudConfigFile,
}
```

 admissionConfig.New 函数主要用来为 admission 建立插件以及 start hook

```go
pluginInitializers, admissionPostStartHook, err = admissionConfig.New(proxyTransport, serviceResolver)
if err != nil {
	lastErr = fmt.Errorf("failed to create admission plugin initializer: %v", err)
	return
}
```

**New**

 NewPluginInitializer 实例化 PluginInitializer，这个结构用来初始化 admission plugin

```go
// New sets up the plugins and admission start hooks needed for admission
func (c *Config) New(proxyTransport *http.Transport, serviceResolver webhook.ServiceResolver) ([]admission.PluginInitializer, server.PostStartHookFunc, error) {
	webhookAuthResolverWrapper := webhook.NewDefaultAuthenticationInfoResolverWrapper(proxyTransport, c.LoopbackClientConfig)
	webhookPluginInitializer := webhookinit.NewPluginInitializer(webhookAuthResolverWrapper, serviceResolver)
 
	var cloudConfig []byte
	if c.CloudConfigFile != "" {
		var err error
		cloudConfig, err = ioutil.ReadFile(c.CloudConfigFile)
		if err != nil {
			klog.Fatalf("Error reading from cloud configuration file %s: %#v", c.CloudConfigFile, err)
		}
	}
	internalClient, err := internalclientset.NewForConfig(c.LoopbackClientConfig)
	if err != nil {
		return nil, nil, err
	}
```

**NewPluginInitializer 实例化 PluginInitializer**

具体实现路径为 `pkg/kubeapiserver/admission/initializer.go`

```go
discoveryClient := cacheddiscovery.NewMemCacheClient(internalClient.Discovery())
discoveryRESTMapper := restmapper.NewDeferredDiscoveryRESTMapper(discoveryClient)
kubePluginInitializer := NewPluginInitializer(
	cloudConfig,
	discoveryRESTMapper,
	quotainstall.NewQuotaConfigurationForAdmission(),
)
```

**admissionPostStartHook 函数是重置 cache 操作**

```go
admissionPostStartHook := func(context genericapiserver.PostStartHookContext) error {
	discoveryRESTMapper.Reset()
	go utilwait.Until(discoveryRESTMapper.Reset, 30*time.Second, context.StopCh)
	return nil
}
 
return []admission.PluginInitializer{webhookPluginInitializer, kubePluginInitializer}, admissionPostStartHook, nil
```

**ApplyTo**

 路径 `k8s.io/apiserver/pkg/server/options/admission.go`

```go
// ApplyTo adds the admission chain to the server configuration.
// In case admission plugin names were not provided by a custer-admin they will be prepared from the recommended/default values.
// In addition the method lazily initializes a generic plugin that is appended to the list of pluginInitializers
// note this method uses:
//  genericconfig.Authorizer
func (a *AdmissionOptions) ApplyTo(
	c *server.Config,
	informers informers.SharedInformerFactory,
	kubeAPIServerClientConfig *rest.Config,
	pluginInitializers ...admission.PluginInitializer,
) error {
	if a == nil {
		return nil
	}
```

**NewFromPlugins**

InitPlugin 主要对插件进行初始化工作，分别调用 Initialize 初始化，在调用 ValidateInitialization 验证是否实现了接口方法 ValidateInitialization

最后包裹 handlers，chainAdmissionHandler 包含了插件的 handler，实现了 Admit 和 Validate 方法，就是对所有插件 handler 调用 Admit 和 Validate 方法

```
func (admissionHandler chainAdmissionHandler) Admit(a Attributes, o ObjectInterfaces) error
func (admissionHandler chainAdmissionHandler) Validate(a Attributes, o ObjectInterfaces) error
```

```
// NewFromPlugins returns an admission.Interface that will enforce admission control decisions of all
// the given plugins.
func (ps *Plugins) NewFromPlugins(pluginNames []string, configProvider ConfigProvider, pluginInitializer PluginInitializer, decorator Decorator) (Interface, error) {
	handlers := []Interface{}
	mutationPlugins := []string{}
	validationPlugins := []string{}
	for _, pluginName := range pluginNames {
		pluginConfig, err := configProvider.ConfigFor(pluginName)
		if err != nil {
			return nil, err
		}
 
		plugin, err := ps.InitPlugin(pluginName, pluginConfig, pluginInitializer)
		if err != nil {
			return nil, err
		}
 
	return chainAdmissionHandler(handlers), nil
}
```

**赋值 AdmissionControl**

具体操作就是又包裹了一下 pluginHandlerWithMetrics

```go
// WithStepMetrics is a decorator for a whole admission phase, i.e. admit or validation.admission step.
func WithStepMetrics(i admission.Interface) admission.Interface {
	return WithMetrics(i, Metrics.ObserveAdmissionStep)
}
 
// WithMetrics is a decorator for admission handlers with a generic observer func.
func WithMetrics(i admission.Interface, observer ObserverFunc, extraLabels ...string) admission.Interface {
	return &pluginHandlerWithMetrics{
		Interface:   i,
		observer:    observer,
		extraLabels: extraLabels,
	}
}
```

##### 使用插件

调用链：

```
main() -> 
app.NewAPIServerCommand() -> 
Run() -> 
CreateServerChain() -> 
createAggregatorServer()->
NewWithDelegate()->
InstallAPIGroups()->
installAPIResources()->
InstallREST()->
Install()->
registerResourceHandlers()->
metrics.InstrumentRouteFunc()->
        -->  restfulUpdateResource               PUT
        -->  restfulPatchResource                PATCH
        -->  restfulCreateNamedResource          POST
        -->  restfulCreateResource               POST
        -->  restfulDeleteResource               DELETE
        -->  restfulDeleteCollection             DELETECOLLECTION
        -->  restfulConnectResource              CONNECT 
```

**registerResourceHandlers**

 可以得到 PUT PATCH POST DELETE DELETECOLLECTION CONNECT 这些 method 用到了 admission 

```go
switch action.Verb {
case "PUT": // Update a resource.
	doc := "replace the specified " + kind
	if isSubresource {
		doc = "replace " + subresource + " of the specified " + kind
	}
	handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulUpdateResource(updater, reqScope, admit))
	
case "PATCH": // Partially update a resource
	handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulPatchResource(patcher, reqScope, admit, supportedTypes))
	
case "POST": // Create a resource.
	var handler restful.RouteFunction
	if isNamedCreater {
		handler = restfulCreateNamedResource(namedCreater, reqScope, admit)
	} else {
		handler = restfulCreateResource(creater, reqScope, admit)
	}
	handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, handler)
	
case "DELETE": // Delete a resource.
	handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulDeleteResource(gracefulDeleter, isGracefulDeleter, reqScope, admit))
	
case "DELETECOLLECTION":
	handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulDeleteCollection(collectionDeleter, isCollectionDeleter, reqScope, admit))
	
case "CONNECT":
	for _, method := range connecter.ConnectMethods() {
		handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulConnectResource(connecter, reqScope, admit, path, isSubresource))
 
}
```



### API server 路由

#### emicklei/go-restful

Kubernetes使用emicklei/go-restful包提供RESTful API服务。所以有必要先来了解下emicklei/go-restful是如何使用的。

1. 创建container
2. 创建ws
3. 生成route，即ws.GET(“/hello”).To(hello)
4. ws.Route(route)
5. container.Add(ws)
6. http.Server{}

即如下代码形式：

```go
container := restful.NewContainer()
ws := new(restful.WebService)
ws.Route(ws.GET("/hello").To(hello))
container.Add(ws)
server := &http.Server{Addr: ":8081", Handler: container}
log.Fatal(server.ListenAndServe())
func hello(req *restful.Request, resp *restful.Response) {
    io.WriteString(resp, "default world")
}
```

#### container的生成

所以，我们第一件事就是寻找在哪生成的container。container的生成函数定义:

```go
func NewAPIServerHandler(name string, s runtime.NegotiatedSerializer, handlerChainBuilder HandlerChainBuilderFn, notFoundHandler http.Handler) *APIServerHandler {
	nonGoRestfulMux := mux.NewPathRecorderMux(name)
	if notFoundHandler != nil {
		nonGoRestfulMux.NotFoundHandler(notFoundHandler)
	}

	gorestfulContainer := restful.NewContainer()
	gorestfulContainer.ServeMux = http.NewServeMux()
	gorestfulContainer.Router(restful.CurlyRouter{}) // e.g. for proxy/{kind}/{name}/{*}
	gorestfulContainer.RecoverHandler(func(panicReason interface{}, httpWriter http.ResponseWriter) {
		logStackOnRecover(s, panicReason, httpWriter)
	})
	gorestfulContainer.ServiceErrorHandler(func(serviceErr restful.ServiceError, request *restful.Request, response *restful.Response) {
		serviceErrorHandler(s, serviceErr, request, response)
	})

	director := director{
		name:               name,
		goRestfulContainer: gorestfulContainer,
		nonGoRestfulMux:    nonGoRestfulMux,
	}

	return &APIServerHandler{
		FullHandlerChain:   handlerChainBuilder(director),
		GoRestfulContainer: gorestfulContainer,
		NonGoRestfulMux:    nonGoRestfulMux,
		Director:           director,
	}
}
```

```go
// NewContainer creates a new Container using a new ServeMux and default router (CurlyRouter)
func NewContainer() *Container {
	return &Container{
		webServices:            []*WebService{},
		ServeMux:               http.NewServeMux(),
		isRegisteredOnRoot:     false,
		containerFilters:       []FilterFunction{},
		doNotRecover:           true,
		recoverHandleFunc:      logStackOnRecover,
		serviceErrorHandleFunc: writeServiceError,
		router:                 CurlyRouter{},
		contentEncodingEnabled: false}
}
```



#### API安装入口

```java
	m := &Master{
		GenericAPIServer:          s,
		ClusterAuthenticationInfo: c.ExtraConfig.ClusterAuthenticationInfo,
	}

	// install legacy rest storage
	if c.ExtraConfig.APIResourceConfigSource.VersionEnabled(apiv1.SchemeGroupVersion) {
...
		if err := m.InstallLegacyAPI(&c, c.GenericConfig.RESTOptionsGetter, legacyRESTStorageProvider); err != nil {
			return nil, err
		}
	}
...
	if err := m.InstallAPIs(c.ExtraConfig.APIResourceConfigSource, c.GenericConfig.RESTOptionsGetter, restStorageProviders...); err != nil {
		return nil, err
	}
```

前面已经分析过了。 

#### Container的启动

Container即GenericAPIServer中的Handler。GenericAPIServer的Run()方法中会启动监听。



#### resthandler

之前已经分析到，Kubernetes是如何注册API的。Kubernetes会把对应路径上的请求交给对应的resthandler处理。所以，resthandler是对请求进行处理并响应的函数。在Kubernetes中，给每一种动作设置了对应的resthandler，如下表格所示(只列出了主要部分)：

| 动作   | 函数           |
| ------ | -------------- |
| GET    | GetResource    |
| LIST   | ListResource   |
| PUT    | UpdateResource |
| PATCH  | PatchResource  |
| POST   | CreateResource |
| DELETE | DeleteResource |
| WATCH  | ListResource   |



调用路径：

```
master.go
InstallLegacyAPI()-> InstallLegacyAPIGroup()-> installAPIResources()-> 
InstallREST()-> Install()-> registerResourceHandlers()
```

```go
func (a *APIInstaller) registerResourceHandlers(path string, storage rest.Storage, ws *restful.WebService) (*metav1.APIResource, error) {
	admit := a.group.Admit

	optionsExternalVersion := a.group.GroupVersion
	if a.group.OptionsExternalVersion != nil {
		optionsExternalVersion = *a.group.OptionsExternalVersion
	}

	resource, subresource, err := splitSubresource(path)
	if err != nil {
		return nil, err
	}

	group, version := a.group.GroupVersion.Group, a.group.GroupVersion.Version

	fqKindToRegister, err := GetResourceKind(a.group.GroupVersion, storage, a.group.Typer)
	if err != nil {
		return nil, err
	}

	versionedPtr, err := a.group.Creater.New(fqKindToRegister)
	if err != nil {
		return nil, err
	}
	defaultVersionedObject := indirectArbitraryPointer(versionedPtr)
	kind := fqKindToRegister.Kind
	isSubresource := len(subresource) > 0

	// If there is a subresource, namespace scoping is defined by the parent resource
	namespaceScoped := true
	if isSubresource {
		parentStorage, ok := a.group.Storage[resource]
		if !ok {
			return nil, fmt.Errorf("missing parent storage: %q", resource)
		}
		scoper, ok := parentStorage.(rest.Scoper)
		if !ok {
			return nil, fmt.Errorf("%q must implement scoper", resource)
		}
		namespaceScoped = scoper.NamespaceScoped()

	} else {
		scoper, ok := storage.(rest.Scoper)
		if !ok {
			return nil, fmt.Errorf("%q must implement scoper", resource)
		}
		namespaceScoped = scoper.NamespaceScoped()
	}

	// what verbs are supported by the storage, used to know what verbs we support per path
	creater, isCreater := storage.(rest.Creater)
	namedCreater, isNamedCreater := storage.(rest.NamedCreater)
	lister, isLister := storage.(rest.Lister)
	getter, isGetter := storage.(rest.Getter)
	getterWithOptions, isGetterWithOptions := storage.(rest.GetterWithOptions)
	gracefulDeleter, isGracefulDeleter := storage.(rest.GracefulDeleter)
	collectionDeleter, isCollectionDeleter := storage.(rest.CollectionDeleter)
	updater, isUpdater := storage.(rest.Updater)
	patcher, isPatcher := storage.(rest.Patcher)
	watcher, isWatcher := storage.(rest.Watcher)
	connecter, isConnecter := storage.(rest.Connecter)
	storageMeta, isMetadata := storage.(rest.StorageMetadata)
	storageVersionProvider, isStorageVersionProvider := storage.(rest.StorageVersionProvider)
	if !isMetadata {
		storageMeta = defaultStorageMetadata{}
	}
	exporter, isExporter := storage.(rest.Exporter)
	if !isExporter {
		exporter = nil
	}

	versionedExportOptions, err := a.group.Creater.New(optionsExternalVersion.WithKind("ExportOptions"))
	if err != nil {
		return nil, err
	}

	if isNamedCreater {
		isCreater = true
	}

	var versionedList interface{}
	if isLister {
		list := lister.NewList()
		listGVKs, _, err := a.group.Typer.ObjectKinds(list)
		if err != nil {
			return nil, err
		}
		versionedListPtr, err := a.group.Creater.New(a.group.GroupVersion.WithKind(listGVKs[0].Kind))
		if err != nil {
			return nil, err
		}
		versionedList = indirectArbitraryPointer(versionedListPtr)
	}

	versionedListOptions, err := a.group.Creater.New(optionsExternalVersion.WithKind("ListOptions"))
	if err != nil {
		return nil, err
	}
	versionedCreateOptions, err := a.group.Creater.New(optionsExternalVersion.WithKind("CreateOptions"))
	if err != nil {
		return nil, err
	}
	versionedPatchOptions, err := a.group.Creater.New(optionsExternalVersion.WithKind("PatchOptions"))
	if err != nil {
		return nil, err
	}
	versionedUpdateOptions, err := a.group.Creater.New(optionsExternalVersion.WithKind("UpdateOptions"))
	if err != nil {
		return nil, err
	}

	var versionedDeleteOptions runtime.Object
	var versionedDeleterObject interface{}
	deleteReturnsDeletedObject := false
	if isGracefulDeleter {
		versionedDeleteOptions, err = a.group.Creater.New(optionsExternalVersion.WithKind("DeleteOptions"))
		if err != nil {
			return nil, err
		}
		versionedDeleterObject = indirectArbitraryPointer(versionedDeleteOptions)

		if mayReturnFullObjectDeleter, ok := storage.(rest.MayReturnFullObjectDeleter); ok {
			deleteReturnsDeletedObject = mayReturnFullObjectDeleter.DeleteReturnsDeletedObject()
		}
	}

	versionedStatusPtr, err := a.group.Creater.New(optionsExternalVersion.WithKind("Status"))
	if err != nil {
		return nil, err
	}
	versionedStatus := indirectArbitraryPointer(versionedStatusPtr)
	var (
		getOptions             runtime.Object
		versionedGetOptions    runtime.Object
		getOptionsInternalKind schema.GroupVersionKind
		getSubpath             bool
	)
	if isGetterWithOptions {
		getOptions, getSubpath, _ = getterWithOptions.NewGetOptions()
		getOptionsInternalKinds, _, err := a.group.Typer.ObjectKinds(getOptions)
		if err != nil {
			return nil, err
		}
		getOptionsInternalKind = getOptionsInternalKinds[0]
		versionedGetOptions, err = a.group.Creater.New(a.group.GroupVersion.WithKind(getOptionsInternalKind.Kind))
		if err != nil {
			versionedGetOptions, err = a.group.Creater.New(optionsExternalVersion.WithKind(getOptionsInternalKind.Kind))
			if err != nil {
				return nil, err
			}
		}
		isGetter = true
	}

	var versionedWatchEvent interface{}
	if isWatcher {
		versionedWatchEventPtr, err := a.group.Creater.New(a.group.GroupVersion.WithKind("WatchEvent"))
		if err != nil {
			return nil, err
		}
		versionedWatchEvent = indirectArbitraryPointer(versionedWatchEventPtr)
	}

	var (
		connectOptions             runtime.Object
		versionedConnectOptions    runtime.Object
		connectOptionsInternalKind schema.GroupVersionKind
		connectSubpath             bool
	)
	if isConnecter {
		connectOptions, connectSubpath, _ = connecter.NewConnectOptions()
		if connectOptions != nil {
			connectOptionsInternalKinds, _, err := a.group.Typer.ObjectKinds(connectOptions)
			if err != nil {
				return nil, err
			}

			connectOptionsInternalKind = connectOptionsInternalKinds[0]
			versionedConnectOptions, err = a.group.Creater.New(a.group.GroupVersion.WithKind(connectOptionsInternalKind.Kind))
			if err != nil {
				versionedConnectOptions, err = a.group.Creater.New(optionsExternalVersion.WithKind(connectOptionsInternalKind.Kind))
				if err != nil {
					return nil, err
				}
			}
		}
	}

	allowWatchList := isWatcher && isLister // watching on lists is allowed only for kinds that support both watch and list.
	nameParam := ws.PathParameter("name", "name of the "+kind).DataType("string")
	pathParam := ws.PathParameter("path", "path to the resource").DataType("string")

	params := []*restful.Parameter{}
	actions := []action{}

	var resourceKind string
	kindProvider, ok := storage.(rest.KindProvider)
	if ok {
		resourceKind = kindProvider.Kind()
	} else {
		resourceKind = kind
	}

	tableProvider, _ := storage.(rest.TableConvertor)

	var apiResource metav1.APIResource
	if utilfeature.DefaultFeatureGate.Enabled(features.StorageVersionHash) &&
		isStorageVersionProvider &&
		storageVersionProvider.StorageVersion() != nil {
		versioner := storageVersionProvider.StorageVersion()
		gvk, err := getStorageVersionKind(versioner, storage, a.group.Typer)
		if err != nil {
			return nil, err
		}
		apiResource.StorageVersionHash = discovery.StorageVersionHash(gvk.Group, gvk.Version, gvk.Kind)
	}

	// Get the list of actions for the given scope.
	switch {
	case !namespaceScoped:
		// Handle non-namespace scoped resources like nodes.
		resourcePath := resource
		resourceParams := params
		itemPath := resourcePath + "/{name}"
		nameParams := append(params, nameParam)
		proxyParams := append(nameParams, pathParam)
		suffix := ""
		if isSubresource {
			suffix = "/" + subresource
			itemPath = itemPath + suffix
			resourcePath = itemPath
			resourceParams = nameParams
		}
		apiResource.Name = path
		apiResource.Namespaced = false
		apiResource.Kind = resourceKind
		namer := handlers.ContextBasedNaming{
			SelfLinker:         a.group.Linker,
			ClusterScoped:      true,
			SelfLinkPathPrefix: gpath.Join(a.prefix, resource) + "/",
			SelfLinkPathSuffix: suffix,
		}

		// Handler for standard REST verbs (GET, PUT, POST and DELETE).
		// Add actions at the resource path: /api/apiVersion/resource
		actions = appendIf(actions, action{"LIST", resourcePath, resourceParams, namer, false}, isLister)
		actions = appendIf(actions, action{"POST", resourcePath, resourceParams, namer, false}, isCreater)
		actions = appendIf(actions, action{"DELETECOLLECTION", resourcePath, resourceParams, namer, false}, isCollectionDeleter)
		// DEPRECATED in 1.11
		actions = appendIf(actions, action{"WATCHLIST", "watch/" + resourcePath, resourceParams, namer, false}, allowWatchList)

		// Add actions at the item path: /api/apiVersion/resource/{name}
		actions = appendIf(actions, action{"GET", itemPath, nameParams, namer, false}, isGetter)
		if getSubpath {
			actions = appendIf(actions, action{"GET", itemPath + "/{path:*}", proxyParams, namer, false}, isGetter)
		}
		actions = appendIf(actions, action{"PUT", itemPath, nameParams, namer, false}, isUpdater)
		actions = appendIf(actions, action{"PATCH", itemPath, nameParams, namer, false}, isPatcher)
		actions = appendIf(actions, action{"DELETE", itemPath, nameParams, namer, false}, isGracefulDeleter)
		// DEPRECATED in 1.11
		actions = appendIf(actions, action{"WATCH", "watch/" + itemPath, nameParams, namer, false}, isWatcher)
		actions = appendIf(actions, action{"CONNECT", itemPath, nameParams, namer, false}, isConnecter)
		actions = appendIf(actions, action{"CONNECT", itemPath + "/{path:*}", proxyParams, namer, false}, isConnecter && connectSubpath)
	default:
		namespaceParamName := "namespaces"
		// Handler for standard REST verbs (GET, PUT, POST and DELETE).
		namespaceParam := ws.PathParameter("namespace", "object name and auth scope, such as for teams and projects").DataType("string")
		namespacedPath := namespaceParamName + "/{namespace}/" + resource
		namespaceParams := []*restful.Parameter{namespaceParam}

		resourcePath := namespacedPath
		resourceParams := namespaceParams
		itemPath := namespacedPath + "/{name}"
		nameParams := append(namespaceParams, nameParam)
		proxyParams := append(nameParams, pathParam)
		itemPathSuffix := ""
		if isSubresource {
			itemPathSuffix = "/" + subresource
			itemPath = itemPath + itemPathSuffix
			resourcePath = itemPath
			resourceParams = nameParams
		}
		apiResource.Name = path
		apiResource.Namespaced = true
		apiResource.Kind = resourceKind
		namer := handlers.ContextBasedNaming{
			SelfLinker:         a.group.Linker,
			ClusterScoped:      false,
			SelfLinkPathPrefix: gpath.Join(a.prefix, namespaceParamName) + "/",
			SelfLinkPathSuffix: itemPathSuffix,
		}

		actions = appendIf(actions, action{"LIST", resourcePath, resourceParams, namer, false}, isLister)
		actions = appendIf(actions, action{"POST", resourcePath, resourceParams, namer, false}, isCreater)
		actions = appendIf(actions, action{"DELETECOLLECTION", resourcePath, resourceParams, namer, false}, isCollectionDeleter)
		// DEPRECATED in 1.11
		actions = appendIf(actions, action{"WATCHLIST", "watch/" + resourcePath, resourceParams, namer, false}, allowWatchList)

		actions = appendIf(actions, action{"GET", itemPath, nameParams, namer, false}, isGetter)
		if getSubpath {
			actions = appendIf(actions, action{"GET", itemPath + "/{path:*}", proxyParams, namer, false}, isGetter)
		}
		actions = appendIf(actions, action{"PUT", itemPath, nameParams, namer, false}, isUpdater)
		actions = appendIf(actions, action{"PATCH", itemPath, nameParams, namer, false}, isPatcher)
		actions = appendIf(actions, action{"DELETE", itemPath, nameParams, namer, false}, isGracefulDeleter)
		// DEPRECATED in 1.11
		actions = appendIf(actions, action{"WATCH", "watch/" + itemPath, nameParams, namer, false}, isWatcher)
		actions = appendIf(actions, action{"CONNECT", itemPath, nameParams, namer, false}, isConnecter)
		actions = appendIf(actions, action{"CONNECT", itemPath + "/{path:*}", proxyParams, namer, false}, isConnecter && connectSubpath)

		// list or post across namespace.
		// For ex: LIST all pods in all namespaces by sending a LIST request at /api/apiVersion/pods.
		// TODO: more strongly type whether a resource allows these actions on "all namespaces" (bulk delete)
		if !isSubresource {
			actions = appendIf(actions, action{"LIST", resource, params, namer, true}, isLister)
			// DEPRECATED in 1.11
			actions = appendIf(actions, action{"WATCHLIST", "watch/" + resource, params, namer, true}, allowWatchList)
		}
	}
	// Create Routes for the actions.

	for _, s := range a.group.Serializer.SupportedMediaTypes() {
		if len(s.MediaTypeSubType) == 0 || len(s.MediaTypeType) == 0 {
			return nil, fmt.Errorf("all serializers in the group Serializer must have MediaTypeType and MediaTypeSubType set: %s", s.MediaType)
		}
	}
	mediaTypes, streamMediaTypes := negotiation.MediaTypesForSerializer(a.group.Serializer)
	allMediaTypes := append(mediaTypes, streamMediaTypes...)
	ws.Produces(allMediaTypes...)

	kubeVerbs := map[string]struct{}{}
	reqScope := handlers.RequestScope{
		Serializer:      a.group.Serializer,
		ParameterCodec:  a.group.ParameterCodec,
		Creater:         a.group.Creater,
		Convertor:       a.group.Convertor,
		Defaulter:       a.group.Defaulter,
		Typer:           a.group.Typer,
		UnsafeConvertor: a.group.UnsafeConvertor,
		Authorizer:      a.group.Authorizer,

		EquivalentResourceMapper: a.group.EquivalentResourceRegistry,

		// TODO: Check for the interface on storage
		TableConvertor: tableProvider,

		// TODO: This seems wrong for cross-group subresources. It makes an assumption that a subresource and its parent are in the same group version. Revisit this.
		Resource:    a.group.GroupVersion.WithResource(resource),
		Subresource: subresource,
		Kind:        fqKindToRegister,

		HubGroupVersion: schema.GroupVersion{Group: fqKindToRegister.Group, Version: runtime.APIVersionInternal},

		MetaGroupVersion: metav1.SchemeGroupVersion,

		MaxRequestBodyBytes: a.group.MaxRequestBodyBytes,
	}
	if a.group.MetaGroupVersion != nil {
		reqScope.MetaGroupVersion = *a.group.MetaGroupVersion
	}
	if a.group.OpenAPIModels != nil && utilfeature.DefaultFeatureGate.Enabled(features.ServerSideApply) {
		reqScope.FieldManager, err = fieldmanager.NewDefaultFieldManager(
			a.group.OpenAPIModels,
			a.group.UnsafeConvertor,
			a.group.Defaulter,
			a.group.Creater,
			fqKindToRegister,
			reqScope.HubGroupVersion,
		)
		if err != nil {
			return nil, fmt.Errorf("failed to create field manager: %v", err)
		}
	}
	for _, action := range actions {
		producedObject := storageMeta.ProducesObject(action.Verb)
		if producedObject == nil {
			producedObject = defaultVersionedObject
		}
		reqScope.Namer = action.Namer

		requestScope := "cluster"
		var namespaced string
		var operationSuffix string
		if apiResource.Namespaced {
			requestScope = "namespace"
			namespaced = "Namespaced"
		}
		if strings.HasSuffix(action.Path, "/{path:*}") {
			requestScope = "resource"
			operationSuffix = operationSuffix + "WithPath"
		}
		if action.AllNamespaces {
			requestScope = "cluster"
			operationSuffix = operationSuffix + "ForAllNamespaces"
			namespaced = ""
		}

		if kubeVerb, found := toDiscoveryKubeVerb[action.Verb]; found {
			if len(kubeVerb) != 0 {
				kubeVerbs[kubeVerb] = struct{}{}
			}
		} else {
			return nil, fmt.Errorf("unknown action verb for discovery: %s", action.Verb)
		}

		routes := []*restful.RouteBuilder{}

		// If there is a subresource, kind should be the parent's kind.
		if isSubresource {
			parentStorage, ok := a.group.Storage[resource]
			if !ok {
				return nil, fmt.Errorf("missing parent storage: %q", resource)
			}

			fqParentKind, err := GetResourceKind(a.group.GroupVersion, parentStorage, a.group.Typer)
			if err != nil {
				return nil, err
			}
			kind = fqParentKind.Kind
		}

		verbOverrider, needOverride := storage.(StorageMetricsOverride)

		switch action.Verb {
		case "GET": // Get a resource.
			var handler restful.RouteFunction
			if isGetterWithOptions {
				handler = restfulGetResourceWithOptions(getterWithOptions, reqScope, isSubresource)
			} else {
				handler = restfulGetResource(getter, exporter, reqScope)
			}

			if needOverride {
				// need change the reported verb
				handler = metrics.InstrumentRouteFunc(verbOverrider.OverrideMetricsVerb(action.Verb), group, version, resource, subresource, requestScope, metrics.APIServerComponent, handler)
			} else {
				handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, handler)
			}

			doc := "read the specified " + kind
			if isSubresource {
				doc = "read " + subresource + " of the specified " + kind
			}
			route := ws.GET(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("read"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
				Returns(http.StatusOK, "OK", producedObject).
				Writes(producedObject)
			if isGetterWithOptions {
				if err := AddObjectParams(ws, route, versionedGetOptions); err != nil {
					return nil, err
				}
			}
			if isExporter {
				if err := AddObjectParams(ws, route, versionedExportOptions); err != nil {
					return nil, err
				}
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		case "LIST": // List all resources of a kind.
			doc := "list objects of kind " + kind
			if isSubresource {
				doc = "list " + subresource + " of objects of kind " + kind
			}
			handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulListResource(lister, watcher, reqScope, false, a.minRequestTimeout))
			route := ws.GET(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("list"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(append(storageMeta.ProducesMIMETypes(action.Verb), allMediaTypes...)...).
				Returns(http.StatusOK, "OK", versionedList).
				Writes(versionedList)
			if err := AddObjectParams(ws, route, versionedListOptions); err != nil {
				return nil, err
			}
			switch {
			case isLister && isWatcher:
				doc := "list or watch objects of kind " + kind
				if isSubresource {
					doc = "list or watch " + subresource + " of objects of kind " + kind
				}
				route.Doc(doc)
			case isWatcher:
				doc := "watch objects of kind " + kind
				if isSubresource {
					doc = "watch " + subresource + "of objects of kind " + kind
				}
				route.Doc(doc)
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		case "PUT": // Update a resource.
			doc := "replace the specified " + kind
			if isSubresource {
				doc = "replace " + subresource + " of the specified " + kind
			}
			handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulUpdateResource(updater, reqScope, admit))
			route := ws.PUT(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("replace"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
				Returns(http.StatusOK, "OK", producedObject).
				// TODO: in some cases, the API may return a v1.Status instead of the versioned object
				// but currently go-restful can't handle multiple different objects being returned.
				Returns(http.StatusCreated, "Created", producedObject).
				Reads(defaultVersionedObject).
				Writes(producedObject)
			if err := AddObjectParams(ws, route, versionedUpdateOptions); err != nil {
				return nil, err
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		case "PATCH": // Partially update a resource
			doc := "partially update the specified " + kind
			if isSubresource {
				doc = "partially update " + subresource + " of the specified " + kind
			}
			supportedTypes := []string{
				string(types.JSONPatchType),
				string(types.MergePatchType),
				string(types.StrategicMergePatchType),
			}
			if utilfeature.DefaultFeatureGate.Enabled(features.ServerSideApply) {
				supportedTypes = append(supportedTypes, string(types.ApplyPatchType))
			}
			handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulPatchResource(patcher, reqScope, admit, supportedTypes))
			route := ws.PATCH(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Consumes(supportedTypes...).
				Operation("patch"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
				Returns(http.StatusOK, "OK", producedObject).
				Reads(metav1.Patch{}).
				Writes(producedObject)
			if err := AddObjectParams(ws, route, versionedPatchOptions); err != nil {
				return nil, err
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		case "POST": // Create a resource.
			var handler restful.RouteFunction
			if isNamedCreater {
				handler = restfulCreateNamedResource(namedCreater, reqScope, admit)
			} else {
				handler = restfulCreateResource(creater, reqScope, admit)
			}
			handler = metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, handler)
			article := GetArticleForNoun(kind, " ")
			doc := "create" + article + kind
			if isSubresource {
				doc = "create " + subresource + " of" + article + kind
			}
			route := ws.POST(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("create"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
				Returns(http.StatusOK, "OK", producedObject).
				// TODO: in some cases, the API may return a v1.Status instead of the versioned object
				// but currently go-restful can't handle multiple different objects being returned.
				Returns(http.StatusCreated, "Created", producedObject).
				Returns(http.StatusAccepted, "Accepted", producedObject).
				Reads(defaultVersionedObject).
				Writes(producedObject)
			if err := AddObjectParams(ws, route, versionedCreateOptions); err != nil {
				return nil, err
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		case "DELETE": // Delete a resource.
			article := GetArticleForNoun(kind, " ")
			doc := "delete" + article + kind
			if isSubresource {
				doc = "delete " + subresource + " of" + article + kind
			}
			deleteReturnType := versionedStatus
			if deleteReturnsDeletedObject {
				deleteReturnType = producedObject
			}
			handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulDeleteResource(gracefulDeleter, isGracefulDeleter, reqScope, admit))
			route := ws.DELETE(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("delete"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
				Writes(deleteReturnType).
				Returns(http.StatusOK, "OK", deleteReturnType).
				Returns(http.StatusAccepted, "Accepted", deleteReturnType)
			if isGracefulDeleter {
				route.Reads(versionedDeleterObject)
				route.ParameterNamed("body").Required(false)
				if err := AddObjectParams(ws, route, versionedDeleteOptions); err != nil {
					return nil, err
				}
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		case "DELETECOLLECTION":
			doc := "delete collection of " + kind
			if isSubresource {
				doc = "delete collection of " + subresource + " of a " + kind
			}
			handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulDeleteCollection(collectionDeleter, isCollectionDeleter, reqScope, admit))
			route := ws.DELETE(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("deletecollection"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(append(storageMeta.ProducesMIMETypes(action.Verb), mediaTypes...)...).
				Writes(versionedStatus).
				Returns(http.StatusOK, "OK", versionedStatus)
			if isCollectionDeleter {
				route.Reads(versionedDeleterObject)
				route.ParameterNamed("body").Required(false)
				if err := AddObjectParams(ws, route, versionedDeleteOptions); err != nil {
					return nil, err
				}
			}
			if err := AddObjectParams(ws, route, versionedListOptions); err != nil {
				return nil, err
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		// deprecated in 1.11
		case "WATCH": // Watch a resource.
			doc := "watch changes to an object of kind " + kind
			if isSubresource {
				doc = "watch changes to " + subresource + " of an object of kind " + kind
			}
			doc += ". deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter."
			handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulListResource(lister, watcher, reqScope, true, a.minRequestTimeout))
			route := ws.GET(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("watch"+namespaced+kind+strings.Title(subresource)+operationSuffix).
				Produces(allMediaTypes...).
				Returns(http.StatusOK, "OK", versionedWatchEvent).
				Writes(versionedWatchEvent)
			if err := AddObjectParams(ws, route, versionedListOptions); err != nil {
				return nil, err
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		// deprecated in 1.11
		case "WATCHLIST": // Watch all resources of a kind.
			doc := "watch individual changes to a list of " + kind
			if isSubresource {
				doc = "watch individual changes to a list of " + subresource + " of " + kind
			}
			doc += ". deprecated: use the 'watch' parameter with a list operation instead."
			handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulListResource(lister, watcher, reqScope, true, a.minRequestTimeout))
			route := ws.GET(action.Path).To(handler).
				Doc(doc).
				Param(ws.QueryParameter("pretty", "If 'true', then the output is pretty printed.")).
				Operation("watch"+namespaced+kind+strings.Title(subresource)+"List"+operationSuffix).
				Produces(allMediaTypes...).
				Returns(http.StatusOK, "OK", versionedWatchEvent).
				Writes(versionedWatchEvent)
			if err := AddObjectParams(ws, route, versionedListOptions); err != nil {
				return nil, err
			}
			addParams(route, action.Params)
			routes = append(routes, route)
		case "CONNECT":
			for _, method := range connecter.ConnectMethods() {
				connectProducedObject := storageMeta.ProducesObject(method)
				if connectProducedObject == nil {
					connectProducedObject = "string"
				}
				doc := "connect " + method + " requests to " + kind
				if isSubresource {
					doc = "connect " + method + " requests to " + subresource + " of " + kind
				}
				handler := metrics.InstrumentRouteFunc(action.Verb, group, version, resource, subresource, requestScope, metrics.APIServerComponent, restfulConnectResource(connecter, reqScope, admit, path, isSubresource))
				route := ws.Method(method).Path(action.Path).
					To(handler).
					Doc(doc).
					Operation("connect" + strings.Title(strings.ToLower(method)) + namespaced + kind + strings.Title(subresource) + operationSuffix).
					Produces("*/*").
					Consumes("*/*").
					Writes(connectProducedObject)
				if versionedConnectOptions != nil {
					if err := AddObjectParams(ws, route, versionedConnectOptions); err != nil {
						return nil, err
					}
				}
				addParams(route, action.Params)
				routes = append(routes, route)

				// transform ConnectMethods to kube verbs
				if kubeVerb, found := toDiscoveryKubeVerb[method]; found {
					if len(kubeVerb) != 0 {
						kubeVerbs[kubeVerb] = struct{}{}
					}
				}
			}
		default:
			return nil, fmt.Errorf("unrecognized action verb: %s", action.Verb)
		}
		for _, route := range routes {
			route.Metadata(ROUTE_META_GVK, metav1.GroupVersionKind{
				Group:   reqScope.Kind.Group,
				Version: reqScope.Kind.Version,
				Kind:    reqScope.Kind.Kind,
			})
			route.Metadata(ROUTE_META_ACTION, strings.ToLower(action.Verb))
			ws.Route(route)
		}
		// Note: update GetAuthorizerAttributes() when adding a custom handler.
	}

	apiResource.Verbs = make([]string, 0, len(kubeVerbs))
	for kubeVerb := range kubeVerbs {
		apiResource.Verbs = append(apiResource.Verbs, kubeVerb)
	}
	sort.Strings(apiResource.Verbs)

	if shortNamesProvider, ok := storage.(rest.ShortNamesProvider); ok {
		apiResource.ShortNames = shortNamesProvider.ShortNames()
	}
	if categoriesProvider, ok := storage.(rest.CategoriesProvider); ok {
		apiResource.Categories = categoriesProvider.Categories()
	}
	if gvkProvider, ok := storage.(rest.GroupVersionKindProvider); ok {
		gvk := gvkProvider.GroupVersionKind(a.group.GroupVersion)
		apiResource.Group = gvk.Group
		apiResource.Version = gvk.Version
		apiResource.Kind = gvk.Kind
	}

	// Record the existence of the GVR and the corresponding GVK
	a.group.EquivalentResourceRegistry.RegisterKindFor(reqScope.Resource, reqScope.Subresource, fqKindToRegister)

	return &apiResource, nil
}

```

### API server 存储

#### registry

在 Kubernetes中，registry 可以对 ETCD中 的 Kubernetes 各类型进行增删查改操作，并对外提供了生成apiGroupInfo 的方法。这里的 registry 包含了两层含义，Storage 和 Registry，如 NodeStorage 和NodeRegistry。Storage 提供了通用的增删查改方法，Regsitry 是对Storage的封装，提供了具体类型的增删查改方法。registry定义在`/pkg/registry`目录下，主要包含：

+ admissionregistration:  定义 admission 相关的 registry 信息

- apps: 定义statefulsets相关的registry信息；
- authentication: 定义tokenreview相关的registry信息；
- authorization: 定义localsubjectaccessreview, selfsubjectaccessreview, subjectaccessreview相关的registry信息；
- autoscaling: 定义horizontalpodautoscaler相关的registry信息；
- batch: 定义scheduledjobs相关的registry信息；
- certificates: 定义certificatesigningrequests相关的registry信息；
- core: 定义componentstatus, configmap, controller, endpoint, event, limitrange, namespace, node, persistentvolume, persistentvolumeclaim, pod, podtemplate, rangeallocation, resourcequota, secret, service, serviceaccount的registry信息；
- extensions: 定义replicationcontrollers, daemonset, deployment, ingress, networkpolicy, podsecuritypolicy, replicaset等相关的registry信息；
- generic: 公共模块，对storage模块进行封装；
- policy: 定义poddisruptionbudgets相关的registry信息；
- rbac: 定义cluserrole, role等相关的registry信息；
- storage: 定义storageclass相关的registry信息。

每个子目录都对应一个APIGroup，如core对应的是v1，每个子目录下都有个rest的目录，其中core目录实现了NewLegacyRESTStorage()方法生成对应的apiGroupInfo，其他目录实现了NewRESTStorage()方法生成对应的apiGroupInfo。apiGroupInfo是联系registry和apiserver的通道。

在NewLegacyRESTStorage()方法中，会调用NewStorage()生成storage，如nodeStorage等，进一步地生成restStorageMap，然后生成apiGroupInfo。

其他APIGroup使用NewRESTStorage()，会调用NewREST()生成storage，如rolesStorage。

我们以core包下的node为例来看下NewStorage()的实现，以rbac包下的role为例来看下NewREST()的实现。

##### nodeStorage

node定义在`/pkg/registry/core/node`目录下。我们先来看下`/pkg/registry/core/rest/storage_core.go`中的NewLegacyRESTStorage()是如何生成 nodeStorage 的，代码如下：

```go
func (c LegacyRESTStorageProvider) NewLegacyRESTStorage(restOptionsGetter generic.RESTOptionsGetter) (LegacyRESTStorage, genericapiserver.APIGroupInfo, error) {
	apiGroupInfo := genericapiserver.APIGroupInfo{
		PrioritizedVersions:          legacyscheme.Scheme.PrioritizedVersionsForGroup(""),
		VersionedResourcesStorageMap: map[string]map[string]rest.Storage{},
		Scheme:                       legacyscheme.Scheme,
		ParameterCodec:               legacyscheme.ParameterCodec,
		NegotiatedSerializer:         legacyscheme.Codecs,
	}
...
	restStorage := LegacyRESTStorage{}
....
	nodeStorage, err := nodestore.NewStorage(restOptionsGetter, c.KubeletClientConfig, c.ProxyTransport)
	if err != nil {
		return LegacyRESTStorage{}, genericapiserver.APIGroupInfo{}, err
	}
    
///
	apiGroupInfo.VersionedResourcesStorageMap["v1"] = restStorageMap

	return restStorage, apiGroupInfo, nil
}
```

##### NewStorage

node的NewStorage()定义在`/pkg/registry/core/node/storage/storage.go`中，主要流程如下：

1. 生成store，store为genericStore
2. 生成nodeREST;
3. 生成NodeStorage。

```go
func NewStorage(optsGetter generic.RESTOptionsGetter, kubeletClientConfig client.KubeletClientConfig, proxyTransport http.RoundTripper) (*NodeStorage, error) {
	store := &genericregistry.Store{
		NewFunc:                  func() runtime.Object { return &api.Node{} },
		NewListFunc:              func() runtime.Object { return &api.NodeList{} },
		PredicateFunc:            node.MatchNode,
		DefaultQualifiedResource: api.Resource("nodes"),

		CreateStrategy: node.Strategy,
		UpdateStrategy: node.Strategy,
		DeleteStrategy: node.Strategy,
		ExportStrategy: node.Strategy,

		TableConvertor: printerstorage.TableConvertor{TableGenerator: printers.NewTableGenerator().With(printersinternal.AddHandlers)},
	}
	options := &generic.StoreOptions{
		RESTOptions: optsGetter,
		AttrFunc:    node.GetAttrs,
		TriggerFunc: map[string]storage.IndexerFunc{"metadata.name": node.NameTriggerFunc},
	}
	if err := store.CompleteWithOptions(options); err != nil {
		return nil, err
	}

	statusStore := *store
	statusStore.UpdateStrategy = node.StatusStrategy

	// Set up REST handlers
	nodeREST := &REST{Store: store, proxyTransport: proxyTransport}
	statusREST := &StatusREST{store: &statusStore}
	proxyREST := &noderest.ProxyREST{Store: store, ProxyTransport: proxyTransport}

	// Build a NodeGetter that looks up nodes using the REST handler
	nodeGetter := client.NodeGetterFunc(func(ctx context.Context, nodeName string, options metav1.GetOptions) (*v1.Node, error) {
		obj, err := nodeREST.Get(ctx, nodeName, &options)
		if err != nil {
			return nil, err
		}
		node, ok := obj.(*api.Node)
		if !ok {
			return nil, fmt.Errorf("unexpected type %T", obj)
		}
		// TODO: Remove the conversion. Consider only return the NodeAddresses
		externalNode := &v1.Node{}
		err = k8s_api_v1.Convert_core_Node_To_v1_Node(node, externalNode, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to convert to v1.Node: %v", err)
		}
		return externalNode, nil
	})
	connectionInfoGetter, err := client.NewNodeConnectionInfoGetter(nodeGetter, kubeletClientConfig)
	if err != nil {
		return nil, err
	}
	nodeREST.connection = connectionInfoGetter
	proxyREST.Connection = connectionInfoGetter

	return &NodeStorage{
		Node:                  nodeREST,
		Status:                statusREST,
		Proxy:                 proxyREST,
		KubeletConnectionInfo: connectionInfoGetter,
	}, nil
}
```

可以看出，NodeStorage 本质是一个genericStore，Store中定义有Create(), Delete(), Get(), List(), Watch()等方法。

```go

func (e *Store) New() runtime.Object {}
func (e *Store) List(ctx context.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {}
func (e *Store) Create(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions) (runtime.Object, error) {
func (e *Store) Update(ctx context.Context, name string, objInfo rest.UpdatedObjectInfo, createValidation rest.ValidateObjectFunc, updateValidation rest.ValidateObjectUpdateFunc, forceAllowCreate bool, options *metav1.UpdateOptions) (runtime.Object, bool, error) {}
func (e *Store) Get(ctx context.Context, name string, options *metav1.GetOptions) (runtime.Object, error) {}
func (e *Store) Delete(ctx context.Context, name string, deleteValidation rest.ValidateObjectFunc, options *metav1.DeleteOptions) (runtime.Object, bool, error) {}


```